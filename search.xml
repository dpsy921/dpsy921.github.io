<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows 中 Navicat Premium 12 破解]]></title>
    <url>%2F2750860619.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于史上最专业的Windows 中 Navicat Premium 12 破解，包你一步到位，不在为激活码而烦恼下载官网下载最新版本的 Navicat Premium 12然后安装到电脑一路下一步破解安装好后先不要打开, 下载 破解工具, 链接: https://pan.baidu.com/s/1nvMMHa_pRVUAJR2IW8ufyg 密码: iy9d下载完成后解压, 找到自己安装的对应版本, 把里面的文件复制到Navicat根目录即可]]></content>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入面向对象]]></title>
    <url>%2F3850728436.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于面向对象的类成员，特殊成员，反射，单例模式，异常处理等类成员1、类类变量绑定方法类方法静态方法属性2、实例（对象）实例变量实例变量类变量定义：写在类的下一级和方法同一级所有方法都能共享且唯一使用类.类变量名称对象.类变量名称练习1234567891011121314151617181920212223class Base: x = 1obj = Base()print(obj.x) # 1obj.y = 123print(oby.y) # 123obj.x = 123print(obj.x) # 123print(Base.x) # 1class Parent: x = 1class Child1(Paerent) passclass Child2(Paerent) passprint(Parent.x,Child1.x,Child2.x) # 1,1,1Child1.x = 2print(Parent.x,Child1.x,Child2.x) # 1,2,1Child2.x = 3print(Parent.x,Child1.x,Child2.x) # 1,2,3总结：找变量优先找自己，自己没有找类或基类，修改或赋值只能在自己的内部设置方法（绑定方法或普通方法）定义：至少有一个self参数执行：先创建对象，有对象.方法()12345678910111213141516class Foo: def func(self,a,b): print(a,b) obj = Foo()obj.func(1,2)class Foo: def __init__(self): self.name = 123 def func(self,a,b) print(self.name,a,b) obj = Foo()obj.func(1,2)静态方法定义：@staticmethod装饰器参数无限制执行：类.静态方法名()对象.静态方法名()(不推荐)12345678910111213141516class Foo: def __init__(self): self.name = 123 def func(self,a,b): print(self.name,a,b) @staticmethod def f1(): print(123)obj = Foo()obj.func(1,2)Foo.f1()obj.f1() # 不推荐类方法定义：@classmethod装饰器至少有cls参数，当前类执行：类.类方法()对象.类方法() (不推荐)1234567891011121314151617class Foo: def __init__(self): self.name = 123 def func(self,a,b): print(self.name,a,b) @classmethod def f1(cls,a,b): print("cls是当前类"，cls) print(123)obj = Foo()obj.func(1,2)Foo.f1(1,2)obj.f1(1,2) # 不推荐属性定义：@property装饰器只有一个self参数执行：对象.方法 不需要加括号123456789class Foo: @property def func(self): print(123) return 33 obj = Foo()result = obj.funcprint(result)1234567891011121314151617181920212223242526# 类的应用class Page: def __init__(self, total_count, current_page, per_page_count=10): # 总的数据条数，当前页码 self.total_count = total_count # 总数据 self.current_page = current_page # 当前页码 self.per_page_count = per_page_count # 每页多少条 @property def start_index(self): # 开始页 return (self.current_page - 1) * self.per_page_count @property def end_index(self): # 结束页 return self.current_page * self.per_page_countUSER_LIST = []for i in range(321): # 321条数据放列表中 USER_LIST.append('alex-%s' % (i,))# 请实现分页展示current_page = int(input("请输入要查看的页码："))p = Page(321, current_page)data_list = USER_LIST[p.start_index:p.end_index] # 起始页、结束页的索引for item in data_list: # 循环打印 print(item)成员修饰符公有，所有地方都能访问到私有，只有自己可以访问到1234567891011# 示例class Foo: def __init__(self,name): self.__name = name def func(self): print(self.__name) obj = Foo('alex')# print(obj.__name) # 错误obj.func()123456789class Foo: __x = 1 @staticmethod def func(): print(Foo.__x) # print(Foo.__x) # 错误Foo.fnc()1234567891011class Foo: def __fun(self): print('msg') def show(self): self.__fun()obj = Foo()# obj.__fun() # 错误obj.show()类的嵌套123456789101112class Foo: def __init__(self,num): self.num = num cls_list = []for i in range(10): cls_list.append(Foo) for i in range(len(cls_list)): obj = cls_list[i](i) print(obj.num) # 0,1,2,3,4,5,6,7,8,91234567class Foo: def __init__(self,num): self.num = num B = Fooobj = B('alex')print(obj.num) # alex123456789101112class Foo: def f1(self): print('f1') def f2(self): print('f2')obj = Foo()v = [ obj.f1,obj.f2 ]for item in v: item() # f1 f21234567891011121314class Foo: def f1(self): print('f1') def f2(self): print('f2') def f3(self): v = [self.f1 , self.f2 ] for item in v: item() obj = Foo()obj.f3() # f1 f212345678910111213class Account: def login(self): pass def register(self): pass def run(self): info = &#123;'1':self.register, '2':self.login &#125; choice = input('请选择:') method = info.get(choice) method()1234567891011121314151617181920class Foo: passclass Foo(object): pass# 在python3中这俩的写法是一样，因为所有的类默认都会继承object类，全部都是新式类。# 如果在python2中这样定义，则称其为：经典类class Foo: pass # 如果在python2中这样定义，则称其为：新式类class Foo(object): pass class Base(object): passclass Bar(Base): pass强制访问私有实例变量1234567class Foo: def __init__(self,name): self.__x = nameobj = Foo('alex')print(obj._Foo__x) # 强制访问私有实例变量特殊成员作用： 就是能够快速实现执行某些方法而生__init__初始化方法1234567891011class Foo: """ 类是干啥的 """ def __init__(self,a1) """ 初始化方法 """ self.a1 = a1 obj = Foo('alex')__new__用于创建空的对象，构造方法12345678910111213class Foo(object): def __init__(self): """ 用于给对象中赋值，初始化方法 """ seif.a = 123 def __new__(cls,*args,**kwargs)： """ 用于创建空的对象，构造方法 """ return object.__new__(cls) obj = Foo()__call__对象加括号可以直接执行12345678class Foo(object): def __call__(self,*args,**kwargs)； print('执行call方法')# 执行方式一 obj = Fooobj()*# 执行方式二Foo()()12345678910111213141516# 简易的网站from wsgiref.simple_server import make_serverdef func(environ,start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) return ['你好'.encode("utf-8") ]class Foo(object): def __call__(self, environ,start_response): start_response("200 OK", [('Content-Type', 'text/html; charset=utf-8')]) return ['你&lt;h1 style="color:red;"&gt;不好&lt;/h1&gt;'.encode("utf-8")]# 作用：写一个网站，用户只要来方法，就自动找到第三个参数并执行。server = make_server('127.0.0.1', 8000, Foo())server.serve_forever()__getitem__用于索引操作，如字典。表示 获取 数据__setitme__用于索引操作，如字典。表示 设置 数据__delitem__用于索引操作，如字典。表示 删除 数据1234567891011121314151617class Foo(object): def __setitem__(self, key, value): pass def __getitem__(self, item): return item + 'uuu' def __delitem__(self, key): passobj1 = Foo()obj1['k1'] = 123 # 内部会自动调用 __setitem__方法val = obj1['xxx'] # 内部会自动调用 __getitem__方法print(val)del obj1['ttt'] # 内部会自动调用 __delitem__ 方法__str__只有在print对象时，会自动化调用此方法12345678910class Foo(object): def __str__(self): """ 只有在打印对象时，会自动化调用此方法，并将其返回值在页面显示出来 :return: """ return 'asdfasudfasdfsad'obj = Foo()print(obj) # asdfasudfasdfsad__dict__去对象中找到所有变量并将其转换为字典12345678910class Foo(object): def __init__(self,name,age,email) self.name = name self.age = age self.email = email obj = Foo('dpsy',23,921921921@qq.com) val = obj.__dict__print(val)# &#123;'name': 'dpsy', 'age': 23, 'email': '921921921@qq.com'&#125;__enter____exit__上下文管理1234567891011121314151617181920212223242526class Foo(object): def do_something(self): print('内部执行')class Context: def __enter__(self): print('进入') return Foo() def __exit__(self, exc_type, exc_val, exc_tb): print('推出')with Context() as ctx: print('内部执行') ctx.do_something() # 读写文件 class Foo(object): def __enter__(self): self.x = open('a.txt',mode='a',encoding='utf-8') return self.x def __exit__(self, exc_type, exc_val, exc_tb): self.x.close()with Foo() as ff: ff.write('dpsy')__add__两个对象相加1234567891011121314val = 5 + 8print(val)val = "大王八" + "一万年"print(val)class Foo(object): def __add__(self, other): return 123 obj1 = Foo()obj2 = Foo()val = obj1 + obj2print(val)约束（抽象类/接口类）约束子类中必须写父类中指定的方法，如果不写，则调用时候就报NotImplementedError12345678910111213141516class Interface(object): def send(self): raise NotImplementedError("子类中没有send")class Message(Interface): def send(self): print("发送短信")class Email(Interface): print(123)obj = Message()obj1 = Email() # 123obj.send() # 发送短信obj1.send() # NotImplementedError: 子类中没有send1234567891011121314151617181920212223# 示例一class BaseMessage(object): def send(self,a1): raise NotImplementedError('字类中必须有send方法') class Msg(BaseMessage): def send(self): passclass Email(BaseMessage): def send(self): passclass Wechat(BaseMessage): def send(self): passclass DingDing(BaseMessage): def send(self): print('钉钉') obj = Email()obj.send()反射​ 根据字符串的形式去某个对象中操作他的成员​ 通过 对象 来获取 实例变量、绑定方法​ 通过 类 来获取 类变量、类方法、静态方法​ 通过 模块名 来获取 模块中的任意变量（普通变量 函数 类）​ 通过 本文件 来获取 本文件中的任意变量​ # getattr(sys.modules[name],’变量名’)getatter（对象，”字符串”）根据字符串的形式去某个对象中获取对象的成员12345678910111213class Foo(object): def __init__(self,name): self.name = name def login(self): print(123)obj = Foo('sd')# 获取变量v1 = getattr(obj,'name')print(v1)# 获取方法method_name = getattr(obj,'login')method_name()hasattr（对象，”字符串”）根据字符串的形式去某个对象中判断是否有该成员，如果对象有该属性返回 True，否则返回 False。1234567class Foo: a = 1 b = 2obj = Foo()print(hasattr(obj,'a'))print(hasattr(obj,'b'))12345678910111213141516171819202122232425262728# 应用from wsgiref.simple_server import make_serverclass View(object): def login(self): return '登陆' def logout(self): return '等处' def index(self): return '首页'def func(environ,start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) # obj = View() # 获取用户输入的URL method_name = environ.get('PATH_INFO').strip('/') if not hasattr(obj,method_name): return ["sdf".encode("utf-8"),] response = getattr(obj,method_name)() return [response.encode("utf-8") ]# 作用：写一个网站，用户只要来方法，就自动找到第三个参数并执行。server = make_server('192.168.12.87', 8000, func)server.serve_forever()satattr（对象，’变量’，’值’）根据字符串的形式去某个对象中设置成员123456class Foo: k1 = 1obj = Foo()setattr(obj,'k1',123) # 相当于obj.k1 = 123print(obj.k1)delattr（对象，’变量’）根据字符串的形式去某个对象中删除成员123456class Foo: k1 = 1obj = Foo()delattr(obj,'k1')print(obj.k1)python一切皆对象，所以以后想要通过字符串的形式操作其内部成员都可以通过反射的机制实现。py文件包类对象单例模式无论实例化多少次，永远用的都是第一次实例化出的对象123456789class Foo: pass# 多例，每实例化一次就创建一个新的对象。obj1 = Foo() # 实例，对象obj2 = Foo() # 实例，对象# 单例，无论实例化多少次，都用第一次创建的那个对象。obj1 = Foo()obj2 = Foo()单例的标准1234567891011121314无论实例化多少次，永远用的都是第一次实例化出的对象from threading import Lockclass Singleton: __instance = None l = RLock() def __new__(cls, *args, **kwargs): # 加这个判断的好处，减少资源浪费，加入没有这个判断再有线程进来先加锁在取判断，这样对象存在直接返回 if cls.__instance: return cls.__instance with cls.lock: if not cls.__instance: cls.__instance = object.__new__(cls) return cls.__instanceobj = Singleton()文件的连接池123456789101112class FileHelper(object): instance = None def __init__(self, path): self.file_object = open(path,mode='r',encoding='utf-8') def __new__(cls, *args, **kwargs): if not cls.instance: cls.instance = object.__new__(cls) return cls.instanceobj1 = FileHelper('x')obj2 = FileHelper('x')通过模块导入的特性也可以实现单列模式12345# jd.py 自定义模块class Foo(object): passobj = Foo()123# app.py 导入模块import jd # 加载jd.py，加载最后会实例化一个Foo对象并赋值给objprint(jd.obj)异常处理基本格式1234try: passexcept Exception as e: pass练习1234567891011try: v = [] v[11111] # IndexErrorexcept ValueError as e: passexcept IndexError as e: passexcept Exception as e: print(e) # e是Exception类的对象，中有一个错误信息。finally: print('最后无论对错都会执行')12345678910111213141516171819202122# 练习一import requeststry: ret = requests.get('http://www.google.com') print(ret.text)except Exception as e: print('请求异常') # 练习二def func(a): try: return a.strip() except Exception as e: pass return Falsev = func('alex')if not v: print('函数执行失败')else: print('结果是',v)练习题12345678910111213141516171819202122232425262728293031# 1. 写函数，函数接受一个列表，请将列表中的元素每个都 +100def func(arg): result = [] for item in arg: if item.isdecimal(): result.append(int(item) + 100) return result # 2. 写函数去，接受一个列表。列表中都是url，请访问每个地址并获取结果。import requests def func(url_list): result = [] try: for url in url_list: response = requests.get(url) result.append(response.text) except Exception as e: pass return result def func2(url_list): result = [] for url in url_list: try: response = requests.get(url) result.append(response.text) except Exception as e: pass return result func(['http://www.baidu.com','http://www.google.com','http://www.bing.com'])主动触发异常123456789101112131415161718try: int('123') raise Exception('阿萨大大是阿斯蒂') # 代码中主动抛出异常except Exception as e: print(e) # 实例def func(): result = True try: with open('x.log',mode='r',encoding='utf-8') as f: data = f.read() if 'alex' not in data: raise Exception() except Exception as e: result = False return result自定义异常12345678910111213141516171819# 实例一class MyException(Exception): passtry: raise MyException('asdf')except MyException as e: print(e) # 实例二class MyException(Exception): def __init__(self,message): super().__init__() self.message = messagetry: raise MyException('asdf')except MyException as e: print(e.message)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的面向对象是谁的对象]]></title>
    <url>%2F3427980016.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于Python中什么是面向对象，为什么要有面向对象，面向对象的三大特性什么是面向对象面向过程和面向对象面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。应用场景：一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。面向对象的程序设计的优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。在python 中面向对象的程序设计并不是全部。面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。了解一些名词：类、对象、实例、实例化类：具有相同特征的一类事物(人、狗、老虎)对象／实例：具体的某一个事物（隔壁阿花、楼下旺财）实例化：类——&gt;对象的过程（这在生活中表现的不明显，我们在后面再慢慢解释）###面向对象基本格式123456789101112131415# 定义class 类名：# 类名首字母大写 def 方法名(self,name):# self不用传参，name必须传参 print(name) return 123 def 方法名(self,name): print(name) return 456 # 调用类的方法1.创建类的对象 # 实例化obj = 类名()2.通过对象调用方法result = obj.方法名('dpsy') # 使用对象调用类的方法print(result) # 返回值123456789101112131415161718192021222324252627282930# 练习题class Db: def db_read(self): # 阅读 pass def db_write(self): # 写 pass def db_delete(self): # 删除 pass def db_update(self): # 更新 pass class File: # 文件 def file_read(self): pass def file_write(self): pass def file_delete(self): pass def file_update(self): pass class Redis: # 数据库 def redis_read(self): pass def redis_write(self): pass def redis_delete(self): pass def redis_update(self): pass对象的作用1、存储一些值，以后方便自己使用2、将数据封装到对象，方便使用1234567891011121314class File: def read(self): with open(self.wenjian,mode="r",encoding='utf-8') as f: data = f.read() return data def write(self,content): with open(self.wenjian,mode='a',encoding='utf-8') as f: f.write(content)# 实例化一个File的对象obj2 = File()# 在对象中写一个wenjian = "test.txt"obj2.wenjian = "info.txt"# 通过对象调用类中的read方法，read方法中的self就是obj.read()obj2.write("dpsy")1234567891011121314151617181920# 示例class Person: def show(self): temp = "我是:%s,年龄:%s,性别:%s"%(self.name,self.age,self.gender) print(temp) p1 = Person()p1.name = "公鸡"p1.age = 65p1.gender = "中"p1.show()p2 = Person()p2.name = "母鸡"p2.age = 18p2.gender = "母"p2.show()# 我是:公鸡,年龄:65,性别:中# 我是:母鸡,年龄:18,性别:母123456789101112131415161718class Person: def __init__(self,n,a,g): # 初始化方法（构造方法），给对象的内部做初始化 self.name = n self.age = a self.gender = g def show(self): temp = "我是:%s,年龄:%s,性别:%s"%(self.name,self.age,self.gender) print(temp) # 类（）实例化对象，自动执行此类中的__init__方法p1 = Person("公鸡"，18，"公")p1.show()p2 = Person("母鸡"，6，"母")p2.show()我是:公鸡,年龄:18,性别:公我是:母鸡,年龄:6,性别:母面向对象的三大特性继承继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类python中类的继承分为：单继承和多继承1234567891011class ParentClass1: #定义父类 passclass ParentClass2: #定义父类 passclass SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass passclass SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类 pass查看继承1234&gt;&gt;&gt; SubClass1.__bases__ #__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类(&lt;class '__main__.ParentClass1'&gt;,)&gt;&gt;&gt; SubClass2.__bases__(&lt;class '__main__.ParentClass1'&gt;, &lt;class '__main__.ParentClass2'&gt;)提示：如果没有指定基类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法（如str）的实现。1234&gt;&gt;&gt; ParentClass1.__bases__(&lt;class 'object'&gt;,)&gt;&gt;&gt; ParentClass2.__bases__(&lt;class 'object'&gt;,)封装封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。所以，在使用面向对象的封装特性时，需要：将内容封装到某处从某处调用被封装的内容第一步：将内容封装到某处self 是一个形式参数，当执行 obj1 = Foo(‘wupeiqi’, 18 ) 时，self 等于 obj1​ 当执行 obj2 = Foo(‘alex’, 78 ) 时，self 等于 obj2所以，内容其实被封装到了对象 obj1 和 obj2 中，每个对象中都有 name 和 age 属性，在内存里类似于下图来保存。第二步：从某处调用被封装的内容调用被封装的内容时，有两种情况：通过对象直接调用通过self间接调用1、通过对象直接调用被封装的内容上图展示了对象 obj1 和 obj2 在内存中保存的方式，根据保存格式可以如此调用被封装的内容：对象.属性名2、通过self间接调用被封装的内容执行类中的方法时，需要通过self间接调用被封装的内容综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。多态多态指的是一类事物有多种形态动物有多种形态：人，狗，猪12345678910111213import abcclass File(metaclass=abc.ABCMeta): #同一类事物:文件 @abc.abstractmethod def click(self): passclass Text(File): #文件的形态之一:文本文件 def click(self): print('open file')class ExeFile(File): #文件的形态之二:可执行文件 def click(self): print('execute file')在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同鸭子类型逗比时刻：Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子’python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。例1：利用标准库中定义的各种‘与文件类似’的对象，尽管这些对象的工作方式像文件，但他们没有继承内置文件对象的方法例2：序列类型有多种形态：字符串，列表，元组，但他们直接没有直接的继承关系]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础模块大全]]></title>
    <url>%2F2354286169.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于Python中函数的random 、hashlib、time /datetime等模块是干甚的，以及内部的方法怎么使用random模块返回随机生成的一个实数random.randint返回随机生成的一个实数123456789101112import random #调用模块def get_random_code(length=6):#变量为6 data = [] for i in range(length):#循环6次 v = random.randint(65,90)#生成65-90之间随机数字 data.append(chr(v))#将v变为字符追加到data列表中 return ''.join(data)#将列表中元素链接，变为空字符串code = get_random_code()print(code)#6位随机字符random.choice从序列中随机抽选一个函数 验证码，抽奖12import randomprint(random.choice([1,2,3,4,5]))random.sample一个奖项多个人12import randomprint(random.sample([1,2,3,4],3)) # [3, 2, 4]random.uniform随机小数12import randomprint(random.uniform(1,5)) # 3.599380534928744random.shuffle将序列顺序打乱 洗牌random.random生成0和1之间的随机浮点数floathashlib模块摘要算法模块 Hmac算法md5/sha1234import hashlibmd5 = hashlib.sha1('盐'.encode())md5.update(b'str')print(md5.hexdigest())两个文件的md5值是相同的123456789import hashlibmd5 = hashlib.md5()#md5.update('hello'.encode())#md5.update('wusir'.encode())md5.update('hello,wusir'.encode())# 46879507bf541e351209c0cd56ac160e46879507bf541e351209c0cd56ac160eprint(md5.hexdigest())123456789101112# 将指定的 “字符串” 进行加密import hashlibdef get_md5(data): obj = hashlib.md5()#md5对象，md5不能反解，但是加密是固定的，就是关系是一一对应，所以有缺陷，可以被对撞出来，如果没有参数，所以md5遵守一个规则，生成同一个对应关系， #如果加了参数，就是在原先加密的基础上再加密一层，这样的话参数只有自己知道，防止被撞库。 obj.update(data.encode('utf-8'))#要对哪个字符串进行加密，就放这里 result = obj.hexdigest()#拿到加密字符串 return result# 返回加密字符串val = get_md5('123')print(val)12345678910111213141516171819202122232425262728293031323334# 应用，用户登录import hashlibUSER_LIST = []def get_md5(data): obj = hashlib.md5("12:;4436ff123ad".encode('utf-8')) obj.update(data.encode('utf-8')) result = obj.hexdigest() return resultdef register(): print('**************用户注册**************')#提示 while True:#循环注册 user = input('请输入用户名:')#输入 if user == 'N':#判断输入是否为N return #结束循环、函数 pwd = input('请输入密码:')#输入密码 temp = &#123;'username':user,'password':get_md5(pwd)&#125;#用户名和密码通过加密放在字典里 USER_LIST.append(temp)#将字典追加到列表里def login(): print('**************用户登陆**************')#提示 user = input('请输入用户名:')#输入 pwd = input('请输入密码:') for item in USER_LIST:#循环列表里的字典 if item['username'] == user and item['password'] == get_md5(pwd):#比较输入的内容与字典里是否一样 return Trueregister()result = login()if result:#判断返回值是否为真 print('登陆成功')else: print('登陆失败')hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。12345import hmacmessage = b'Hello world'key = b'secret'h = hmac.new(key,message,digestmod='MD5')print(h.hexdigest())time /datetime模块时间模块time.time时间戳123import time v = time.time() # 时间戳：1970-1-1 00:00time.timezone当前时区与时间戳相差的秒数12import timeprint(time.timezone) # -28800time.sleep睡几秒datetime.now当前本地时间123from datetime import datetimev1 = datetime.now()print(v1) # 2019-04-18 17:52:33.046206timezone获取东几区时间1234from datetime import datetime,timezone,timedeltatz = timezone(timedelta(hours=7)) # 当前东7区时间v2 = datetime.now(tz)datetime.utcnow当前UTC时间1234from datetime import datetime,timezone,timedeltav3 = datetime.utcnow() # 当前UTC时间print(v3)strftime把datetime格式转换成字符串123456from datetime import datetime,timezone,timedeltav1 = datetime.now()print(v1,type(v1))val = v1.strftime("%Y-%m-%d %H:%M:%S")print(val)datetime.strptime字符串转成datetime1234from datetime import datetime,timezone,timedeltav1 = datetime.strptime('2011-11-11','%Y-%m-%d')print(v1,type(v1))timedeltadatetime时间的加减123456from datetime import datetime,timezone,timedeltav1 = datetime.strptime('2011-11-11','%Y-%m-%d')v2 = v1 - timedelta(days=140)date = v2.strftime('%Y-%m-%d')print(date)时间戳和datetime关系1234567891011import timefrom datetime import datetime,timezone,timedeltactime = time.time()print(ctime)v1 = datetime.fromtimestamp(ctime)print(v1)v1 = datetime.now()val = v1.timestamp()print(val)getpass模块密码不显示（只能在终端运行）密码不显示（只能在终端运行）12345import getpasspwd = getpass.getpass('请输入密码：')if pwd == '123': print('输入正确')sys模块解释器相关模块sys.getrefcount获取一个值的应用计数1234import sysa = [11,22,33]b = aprint(sys.getrefcount(a)) # 3sys.getrecursionlimitpython默认支持的递归数量123import sysprint(sys.getrecursionlimit()) # 1000sys.stdout.writprint (可以查看进度)12345import timefor i in range(1,101): mag = "%s%%\r" %i print(mag,end="") time.sleep(0.05) #从1%长到100%123456789101112import os# 1.读取文件大小(字节)file_size = os.stat('day001.zip').st_size# 文件大小# 2.一点一点的读取文件read_size = 0 # 阅读大小with open('day001.zip',mode='rb') as f1 , open ('a.zip',mode='wb') as f2: while read_size &lt; file_size: chunk = f1.read(1024) #每次最多读取1024字节 f2.write(chunk) read_size += len(chunk) #阅读大小=阅读大小+读取长度 val = int(read_size/file_size * 100) # 求当前读取%数 print('%s%%\r'%val,end='')sys.argv获取用户执行脚本时，传入的参数。12345678910111213141516"""让用户执行脚本传入要删除的文件路径，在内部帮助用将目录删除。C:\Python36\python36.exe D:/code/s21day14/7.模块传参.py D:/testC:\Python36\python36.exe D:/code/s21day14/7.模块传参.py"""import sys# 获取用户执行脚本时，传入的参数。# C:\Python36\python36.exe D:/code/s21day14/7.模块传参.py D:/test# sys.argv = [D:/code/s21day14/7.模块传参.py, D:/test]path = sys.argv[1]# 删除目录import shutilshutil.rmtree(path)sys.path模块搜索 默认Python去导入模块时，会按照sys.path中的路径挨个查找。123# import sys# sys.path.append('D:\\')# import oldboysys.exit（0） 终止程序sys.modules 存储当前程序用到的所有模块，反射文件中的内容123456import demo # 导入自定义py文件import sysprint(demo)print(sys.modules)print(demo is sys.modules['demo'])print(getattr(sys.modules['demo'],'a'))os模块操作系统相关os.path.exists(path)判断文件目录是否存在 ， 如果path存在，返回True；如果path不存在，返回Falseos.path.isfile(path)判断文件是否存在*os.path.basename(file_path) *获取文件名*os.stat(‘file’).st_size *获取文件大小*os.path.getsize(path) *获取文件大小*os.path.abspath() **获取一个文件的绝对路径 （__file__）获取当前文件绝对路径 **os.path.isabs(path) *判断是否为绝对路径12345678910path = '20190409_192149.mp4' # E:\Python_WorkSpace\day014 装饰器带参数\day001.zipimport osv1 = os.path.abspath(path)print(v1)# E:\Python_WorkSpace\day014 装饰器带参数\day001.zip# 获取当前文件的绝对路径a = os.path.abspath(__file__)print(a)*os.path.dirname *获取路径的上级目录12345import osv = r"E:\Python_WorkSpace\day014 装饰器带参数\day001.zip"print(os.path.dirname(v))# E:\Python_WorkSpace\day014 装饰器带参数*os.path.join *路径的拼接12345678910import ospath = "E:\Python_WorkSpace\day014" # user/index/inx/fasd/v = 'n.txt'result = os.path.join(path,v)print(result)result = os.path.join(path,'n1','n2','n3')print(result)# E:\Python_WorkSpace\day014\n.txt# E:\Python_WorkSpace\day014\n1\n2\n3os.listdir查看一个目录下所有的文件【第一层】12345import osresult = os.listdir(r'E:\Python_WorkSpace\day014 装饰器带参数')for path in result: print(path)*os.walk *** 查看一个目录下所有的文件【所有层】**12345678import osresult = os.walk(r'E:\Python_WorkSpace\day014 装饰器带参数')for a,b,c in result: # a,正在查看的目录 b,此目录下的文件夹 c,此目录下的文件 for item in c: path = os.path.join(a,item) print(path)os.makedirs创建目录和子目录123456789import osfile_path = r'db\xx\xo\xxxxx.txt' # 文件路径file_folder = os.path.dirname(file_path) # 文件夹if not os.path.exists(file_folder): # 判断文件夹是否存在 os.makedirs(file_folder) # 创建文件夹with open(file_path,mode='w',encoding='utf-8') as f: f.write('asdf')os.renname重命名12import osos.rename('db','sb')shtil模块高级的 文件、文件夹、压缩包 处理模块shutil.rmtree删除目录12import shutilshutil.rmtree(path)shutil.move重命名；移动文件12import shutilshutil.move('test','ttt')shutil.make_archive压缩文件夹123import shutilshutil.make_archive('cade\asd','zip',r'E:\Python_WorkSpace\day016 模块\abc')shutil.unpack_archive解压文件123import shutilshutil.unpack_archive('abc.zip',extract_dir=r'E:\Python_WorkSpace\day016 模块\abc',format='zip')12345678910111213141516# 练习# 1.压缩lizhongwei文件夹 zip# 2.放到到 code 目录（默认不存在）# 3.将文件解压到D:\x1目录中。import osimport shutilfrom datetime import datetimectime = datetime.now().strftime('%Y-%m-%d-%H-%M-%S') # 将当前时间转换成字符串if not os.path.exists('code'): # 判断 code 文件目录是否存在 os.makedirs('code') # 创建 codeshutil.make_archive(os.path.join('code',ctime),'zip','D:\code\s21day16\lizhongwei') # 压缩文件 在code文件夹中，名称为2019-04-18-17-12-24压缩文件file_path = os.path.join('code',ctime) + '.zip' #被解压文件名称 shutil.unpack_archive(file_path,r'D:\x1','zip') #解压文件到指定目录json / pickle模块序列化二者优缺点json,优点：所有语言通用；缺点：只能序列化基本的数据类型所有字符串都是双引号；最外层只能是列表或字典存在字典的key只能是str;不能连续load多次pickle,优点：python中几乎所有的东西都能被序列化（socket对象）；缺点：序列化的内容只有python认识支持连续load多次一个特殊的字符串。【长得像列表、字典、字符串、数字、真假】123456789101112131415161718+-------------------+---------------+ | Python | JSON | +===================+===============+ | dict | object | +-------------------+---------------+ | list, tuple | array | +-------------------+---------------+ | str | string | +-------------------+---------------+ | int, float | number | +-------------------+---------------+ | True | true | +-------------------+---------------+ | False | false | +-------------------+---------------+ | None | null | +-------------------+---------------+dumps序列化，将python的值转换为json格式的字符串(str/bytes类型)。loads反序列化，将json格式的字符串转换为python的值。123456789import picklev = &#123;1,2,3,4&#125;# 序列化，将python的值转换为json格式的字符串。val = pickle.dumps(v)print(val)# 反序列化，将json格式的字符串转换为python的值。data = pickle.loads(val)print(data,type(data))123456789# 示例一import jsonv = [1,2,3,4,'frfed','tgrf',[1,3,2]]# 序列化，将python的值转换为json格式的字符串。v1 = json.dumps(v)print(v1,type(v1)) # [1, 2, 3, 4, "frfed", "tgrf", [1, 3, 2]] &lt;class 'str'&gt;# 反序列化，将json格式的字符串转换为python的值。v3 = json.loads(v1)print(v3,type(v3)) # [1, 2, 3, 4, 'frfed', 'tgrf', [1, 3, 2]] &lt;class 'list'&gt;字典或列表中如有中文，序列化时想要保留中文显示:12345v = &#123;'k1':"asdf",'k2':'中文'&#125;import jsonval = json.dumps(v,ensure_ascii=False)print(val) # &#123;"k1": "alex", "k2": "李杰"&#125;dump将字典以特殊格式写到文件中load读取文件中内容转换成字典12345678910111213v = &#123;'k1':"asdf",'k2':'中文'&#125;import jsonf = open('x.txt',mode='w',encoding='utf-8')val = json.dump(v,f)print(val) # Nonef.close # &#123;"k1": "asdf", "k2": "\u4e2d\u6587"&#125;import jsonf = open('x.txt',mode='r',encoding='utf-8')val = json.load(f)f.closeprint(val,type(val)) # &#123;'k1': 'asdf', 'k2': '中文'&#125; &lt;class 'dict'&gt;1234567891011import picklev = &#123;1,2,3,4&#125;f = open('x.txt',mode='wb')val = pickle.dump(v,f)f.close()f = open('x.txt',mode='rb')data = pickle.load(f)f.close()print(data)importlib模块根据字符串的形式导入模块。1模块 = importlib.import_module('utils.redis')12345678910111213141516171819# 示例一import importlib# 用字符串形式导入模块redis = importlib.import_module('utils.redis')# 用字符串的形式去对象（模块）找到他的成员getattr(redis,'func')()# 示例二import importlibpath = 'utils.redis.func'module_path,func_name = path.rsplit('.',maxsplit=1)module_object = importlib.import_module(module_path)getattr(module_object,func_name)()开放封闭原则对配置文件开放对源代码封闭12345678910111213import importlibmiddleware_classes = [ 'utils.redis.Redis', # 'utils.mysql.MySQL', 'utils.mongo.Mongo']for path in middleware_classes: module_path,class_name = path.rsplit('.',maxsplit=1) module_object = importlib.import_module(module_path)# from utils import redis cls = getattr(module_object,class_name) obj = cls() obj.connect()collections模块加强版数据结构OrderedDict有序字典1234567891011121314151617# 示例一from collections import OrderedDictinfo = OrderedDict()info['k1'] = 123info['k2'] = 456print(info.keys()) # odict_keys(['k1', 'k2'])print(info.values()) # odict_values([123, 456])print(info.items()) # odict_items([('k1', 123), ('k2', 456)])# 示例二from collections import OrderedDictodic = OrderedDict([('a', 1), ('b', 2), ('c', 3)])print(odic) # OrderedDict([('a', 1), ('b', 2), ('c', 3)])for k in odic: print(k,odic[k])deque双端队列12defaultDict默认字典，给value设置一个默认值12namedtuple可命名元祖应用：创建一个类，这个类没有办法，所有的属性的值都不能修改123456from collections import namedtuple # 可命名元组Course = namedtuple('Course',['name','price','teacher'])python = Course('python',19800,'alex')print(python) # Course(name='python', price=19800, teacher='alex')print(python.name) # pythonprint(python.price) # 19800logging模块日志模块报警等级12345678CRITICAL = 50 # 最高FATAL = CRITICALERROR = 40WARNING = 30WARN = WARNINGINFO = 20DEBUG = 10NOTSET = 0 # 最低日志处理本质：Logger/FileHandler/Formatter应用：统计用；做故障排除debug；记录错误，完成代码优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 示例一import loggingfile_handler1 = logging.FileHandler('x2.log', 'a', encoding='utf-8') # 构造参数fmt1 = logging.Formatter(fmt="%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s")file_handler1.setFormatter(fmt1)# file_handler2 = logging.FileHandler('x2.log', 'a', encoding='utf-8')# fmt2 = logging.Formatter(fmt="%(asctime)s: %(message)s")# file_handler2.setFormatter(fmt2)logger = logging.Logger('xxxxxx', level=logging.ERROR)logger.addHandler(file_handler1)# logger.addHandler(file_handler2)# 示例二import logginglogging.basicConfig( # 函数各参数 filename='cmdb1.log', # 日志文件名称 format='%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', # 指定日志输出格式和内容 datefmt='%Y-%m-%d %H:%M:%S %p', # 指定时间格式 level=logging.ERROR # 日志报警等级)# 无效 日志只配置一次logging.basicConfig( filename='cmdb2.log', format='%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p', level=logging.ERROR)logging.error('alex') # 报警内容logging.basicConfig函数各参数:filename: 指定日志文件名filemode: 和file函数意义相同，指定日志文件的打开模式，'w'或'a'format: 指定输出的格式和内容，format可以输出很多有用信息，如上例所示: %(levelno)s: 打印日志级别的数值 %(levelname)s: 打印日志级别名称 %(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0] %(filename)s: 打印当前执行程序名 %(funcName)s: 打印日志的当前函数 %(lineno)d: 打印日志的当前行号 %(asctime)s: 打印日志的时间 %(thread)d: 打印线程ID %(threadName)s: 打印线程名称 %(process)d: 打印进程ID %(message)s: 打印日志信息datefmt: 指定时间格式，同time.strftime()level: 设置日志级别，默认为logging.WARNINGstream: 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略---------------------logging.basicconfig使用方便不能实现编码问题；不能同时向文件和屏幕输出logging.debuglogging.warninglogger对象 复杂的创建流程创建一个logger对象创建一个文件操作符创建一个屏幕操作符创建一个格式操作;给logger对象绑定 文件操作符给logger对象绑定 屏幕操作符给文件操作符设定格式给屏幕操作符设定格式1234567891011import logginglogger = logging.getLogger() # 创建一个logger对象fh = logging.FileHandler('log.log') # 创建一个文件操作符sh = logging.StreamHandler() # 创建一个屏幕操作符logger.addHandler(fh) # 给logger对象绑定 文件操作符logger.addHandler(sh) # 给logger对象绑定 屏幕操作符formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # 创建一个格式fh.setFormatter(formatter) # 给文件操作符设定格式sh.setFormatter(formatter) # 给屏幕操作符设定格式logger.warning('message') #推荐处理日志方式1234567891011import loggingfile_handler = logging.FileHandler(filename='x1.log', mode='a', encoding='utf-8',)logging.basicConfig( format='%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p', handlers=[file_handler,], level=logging.ERROR)logging.error('你好')12345678910111213141516# 日志切割import timeimport loggingfrom logging import handlers# file_handler = logging.FileHandler(filename='x1.log', mode='a', encoding='utf-8',)file_handler = handlers.TimedRotatingFileHandler(filename='x3.log', when='s', interval=5, encoding='utf-8')logging.basicConfig( format='%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p', handlers=[file_handler,], level=logging.ERROR)for i in range(1,100000): time.sleep(1) logging.error(str(i))注意事项12345678910111213141516# 在应用日志时，如果想要保留异常的堆栈信息。import loggingimport requestslogging.basicConfig( filename='wf.log', format='%(asctime)s - %(name)s - %(levelname)s -%(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p', level=logging.ERROR)try: requests.get('http://www.xxx.com')except Exception as e: msg = str(e) # 调用e.__str__方法 logging.error(msg,exc_info=True)copy模块re模块模块转义符正则表达式中的转义符在python的字符串中也刚好有转移的作用但是正则表达式中的转义符和字符串中的转义符并没关系，且还容易有冲突，为了避免这种冲突，我们所有的正则都以在工具中的测试结果为结果，然后只需要在正则和待匹配的字符串外面都加r即可12345print('\\\\n') # //nprint('\\n') # /nprint(r'\\n') # //nprint(r'\n') # /n*re.findall *匹配字符串中所有规则的项，返回一个列表；未匹配返回一个空列表1234import reret = re.findall('\d+','asadf451sdfdfb645d')print(ret) # ['451', '645']*re.search *** 会从头到尾从带匹配，匹配字符串取出第一个符合条件的项，如果匹配到了，返回一个对象，用group取值；如果没匹配到，返回None，不能用group，会报错**12345import reret = re.search('\d+','asadf451sdfdfb645d')print(ret) # &lt;_sre.SRE_Match object; span=(5, 8), match='451'&gt; span 是索引 match 是匹配到的项if ret: print(ret.group()) # 451*re.match *会从头匹配字符串中取出从第一个字符开始是否符合规则，如果符合，就返回对象，用group取值；如果不符合，就返回None，相当于 match = search + ^正则123456import reret = re.match('\d+','45adf451sdfdfb645d')print(ret)if ret: print(ret.group())re.finditer在查询的结果超过1个的情况下，能够有效的节省内存，降低空间复杂度，从而也降低了时间复杂度123456import reret = re.finditer("\d+",'cdfz56x31d144df'*1000)print(ret) # &lt;callable_iterator object at 0x000002541A7874A8&gt; 迭代器for i in ret: # 循环迭代出每个元素 print(i.group()) # 56 31 144 ......compile在同一个正则表达式重复使用多次的时候使用能够减少时间的开销，属于内置函数1234567891011import reret = re.compile('\d+')print(ret) # re.compile('\\d+')r1 = ret.search('alex83')print(r1) # &lt;_sre.SRE_Match object; span=(4, 6), match='83'&gt;r2 = ret.findall('wusir74')print(r2) # ['74']r3 = ret.finditer('taibai40')for i in r3: print(i.group()) # 40re.split分割，根据正则规则切割，返回列表，默认不保留切掉的内容123456import reret1 = re.split('\d\d','alex83wusir74taibai') # 默认自动保留分组中的内容print(ret1) # ['alex', 'wusir', 'taibai']ret2 = re.split('\d(\d)','alex83wusir74taibai')print(ret2) # ['alex', '3', 'wusir', '4', 'taibai']re.sub替换，默认替换所有，可以使用替换深度参数re.subn​ 替换，返回元祖12345678910import reret1 = re.sub('\d','D','alex83wusir74taibai')print(ret1) # alexDDwusirDDtaibairet2 = re.sub('\d','D','alex83wusir74taibai',1)print(ret2) # alexD3wusir74taibairet3 = re.subn('\d','D','alex83wusir74taibai')print(ret3) # ('alexDDwusirDDtaibai', 4)分组findall遇到正则表达式中的分组，会优先显示分组中的内容1234import reret = re.findall('\d(\d)','sdfgfgvbnk83')print(ret) # ['3']split遇到正则表达式中的分组，会保留分组中本来应该被切割掉的内容123import reret1 = re.split('(\d\d)','alex83wusir74taibai') # 默认自动保留分组中的内容print(ret1) # ['alex', '83', 'wusir', '74', 'taibai']group(加参数)123456s1 = '&lt;h1&gt;wahaha&lt;/h1&gt;'ret = re.search('&lt;(\w+)&gt;(.*?)&lt;/\w+&gt;',s1)print(ret) # &lt;_sre.SRE_Match object; span=(0, 15), match='&lt;h1&gt;wahaha&lt;/h1&gt;'&gt;print(ret.group(0)) # group参数默认为0 表示取整个正则匹配的结果 &lt;h1&gt;wahaha&lt;/h1&gt;print(ret.group(1)) # 取第一个分组中的内容 h1print(ret.group(2)) # 取第二个分组中的内容 wahaha分组命名 (?P&lt;名字&gt;正则表达式)search 取分组中的内容 通过索引；通过组名取123456s1 = '&lt;h1&gt;wahaha&lt;/h1&gt;'ret = re.search('&lt;(?P&lt;tag&gt;\w+)&gt;(?P&lt;cont&gt;.*?)&lt;/\w+&gt;',s1)print(ret) # &lt;_sre.SRE_Match object; span=(0, 15), match='&lt;h1&gt;wahaha&lt;/h1&gt;'&gt;print(ret.group(0)) # group参数默认为0 表示取整个正则匹配的结果 &lt;h1&gt;wahaha&lt;/h1&gt;pprint(ret.group('tag')) # 取tag分组中的内容print(ret.group('cont')) # 取cont分组中的内容分组引用 (?P=组名) 这个组中的内容必须完全和之前已经存在的组匹配到的内容一模一样12345import res1 = '&lt;h1&gt;wahaha&lt;/h1&gt;'ret = re.search('&lt;(?P&lt;tag&gt;\w+)&gt;.*?&lt;/(?P=tag)&gt;',s1)print(ret.group('tag')) # h1取消分组优先 （?:）123456# 有的时候我们想匹配的内容包含在不相匹配的内容当中，这个时候只需要把不想匹配的先匹配出来，再通过手段去掉import reret=re.findall(r"\d+\.\d+|(\d+)","1-2*(60+(-40.35/5)-(-4*3))")print(ret) # ['1', '2', '60', '', '5', '4', '3']ret.remove('')print(ret) # ['1', '2', '60', '5', '4', '3'][] 和 [^] 带有特殊意义的元字符到字符组内大部分都会取消它的特殊含义[()+*.][(\-)] -的位置决定了它的意义，写在字符组的第一位位置或者最后一个位置就表示一个普通的横杠写在字符组的其他任何位置都会表示一个范围练习1234567# 检测用户输入的内容是否是一个合法的身份证号 网页的合法输入（手机号码 qq号码 银行卡号 邮箱地址）'^[1-9]\d&#123;14&#125;(\d&#123;2&#125;[\dx])?$'import reinp = input('&gt;&gt;&gt;').strip()re.match('[1-9]\d&#123;14&#125;(\d&#123;2&#125;[\dx])?$',inp) # 首选re.search('^[1-9]\d&#123;14&#125;(\d&#123;2&#125;[\dx])?$',inp)re.findall('^[1-9]\d&#123;14&#125;(\d&#123;2&#125;[\dx])?$',inp)struct模块pack 能够把所有的数字都固定的转换成4字节dis模块dis.dis查看计算机指令总结函数高级 5*嵌套装饰器模块分类和定义 4*内置模块ossys…第三方requestsxlrd自定义模块文件文件夹 + init.py【包】导入模块sys.path导入importfrom xx.xxx import xx]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块介绍]]></title>
    <url>%2F2936349916.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于Python中为什么要有模块，使用模块的好处，如何使用模块，以及包的概念模块简介为什么要有模块？我们已经知道把实现具体功能的代码放入函数中，能够方便今后调用。现在我们把实现相关功能的函数汇集起来放到一个py文件中，方便管理和调用。这样每个py文件中的代码都相对较少，实现的功能都是相似或相关的功能。在Python中一个py文件就叫一个模块（module）。使用模块的好处提高代码的可读性。提高代码的可维护性。如何使用模块1、使用内置模块Python本身就内置了很多非常有用的模块，只要安装完Python，这些模块就可以使用了。2、自定义模块3、使用第三方模块Python中使用pip来安装第三方模块。例如：pip install django无论是内置模块还是第三方模块，具体的使用方式都是：1234567891011# 方式一 导入模块中所有函数import abcabc.func()# 方式二from abc import func # # from 模块 import 函数from abc import showfrom abc import func,show # from 模块 import 函数 / 函数() from abc import *from abc import func as f # from 模块 import 函数 as 别名 别名()模块和要执行的py文件在同一目录 且 需要 模块中的很多功能时，推荐用： import 模块其他推荐：from 模块 import 模块 / 模块.函数()其他推荐：from 模块.模块 import 函数 函数()模块查找路径发现，自己写的模块只能在当前路径下的程序里才能导入，换一个目录再导入自己的模块就报错说找不到了， 这是为什么？这与导入模块的查找路径有关1import sysprint(sys.path)输出（注意不同的电脑可能输出的不太一样）1['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']你导入一个模块时，Python解释器会按照上面列表顺序去依次到每个目录下去匹配你要导入的模块名，只要在一个目录下匹配到了该模块名，就立刻导入，不再继续往后找。注意列表第一个元素为空，即代表当前目录，所以你自己定义的模块在当前目录会被优先导入。我们自己创建的模块若想在任何地方都能调用，那就得确保你的模块文件至少在模块路径的查找列表中。我们一般把自己写的模块放在一个带有“site-packages”字样的目录里，我们从网上下载安装的各种第三方的模块一般都放在这个目录。包的概念Python中的包是一个包含多个模块文件的目录，按包来组织模块。注意：Python中包的每个目录下都要有一个__init__.py文件，否则，就是普通目录。十二分注意：不要将自己的模块文件名与Python自带的模块名冲突。不要将自己的模块文件名与Python自带的模块名冲突。不要将自己的模块文件名与Python自带的模块名冲突。例如：内置的time模块，你自己创建的py文件就不要命名成time.py，否则就不能正常使用内置的time模块了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数的高级]]></title>
    <url>%2F1705878977.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于Python中函数的小、中、高级的用法，闭包，lambda表达式，内置函数，以及什么是装饰器、迭代器、生成器等函数小高级函数名作为变量带括号就执行函数，返回函数返回值；不加括号指向函数地址，函数不执行函数可以作为字典的键值，可以作为键12345678910111213# 典例一def func(): print(123) v1 = func # func函数不执行func # func函数不执行v1（） # 执行func函数# 典例二def func(): print(123) v1 = func() # func函数返回值func() # 执行func函数print(v1) # None1234567891011def func(): print(123) func_list = [func, func, func] # func_list为三个func函数地址func_list = [func(), func(), func()] # [None, None, None]# func_list[0]()# func_list[1]()# func_list[2]()for item in func_list: v = item() #123 循环3次 print(v) #None12345678910def func(): print(123)def bar(): print(666)info = &#123;'k1': func, 'k2': bar&#125;info['k1']() # 执行函数func 123info['k2']() # 执行函数bar 6661234567891011121314def func(): return 123func_list1 = [func,func,func]func_list2 = [func(),func(),func()]print(func_list1) #func()函数地址 * 3print(func_list2) # 123 123 123info = &#123; 'k1':func, 'k2':func(),&#125;print(info) # &#123;'k1': &lt;function func at 0x000001D5315DDA60&gt;, 'k2': 123&#125;函数当作参数当参数时有（），得到返回值；当参数时无（），得到函数地址12345678910def func(arg): print(arg) func(1) # 执行func 1func([1,2,3,4]) # 执行func [1,2,3,4]def show(): return 999func(show) # show不执行 指向函数地址func(show()) # show执行 99912345678def func(arg): v1 = arg()#函数show执行 v1为函数show返回值 print(v1) def show(): print(666)#输出666 func(show)#指向函数show地址不执行123456789def func(arg): v1 = arg() print(v1) def show(): print(666) result = func(show)#result为函数func的返回值print(result)数据类型中的方法到底有没有返回值？无返回值12v = [11,22,33]v.append(99) # 无返回值仅有返回值：123456v = "熊大"result = v.split('l')v = &#123;'k1':'v2'&#125;result1 = v.get('k1')result2 = v.keys()有返回+修改数据12v = [11,22,33]result = v.pop()常用方法有返回值str 字符串的所有方法基本上都是返回值为新值strip，返回字符串split，返回列表replace，返回字符串join，返回字符串。list 列表所有方法基本上都是返回值Noneappend，无insert，无pop，返回要删除的数据remove，无find/index，返回索引的位置。dictget ，返回指定键值keys，返回所有键values，返回所有值items，返回所有键值对函数内部的数据是否会混乱。函数内部执行相互之间不会混乱执行完毕 + 内部元素不被其他人使用 =&gt; 销毁函数中高级函数做返回值就找函数何时被谁创建123456def func(): print(123) #输出123def bar(): return fun #返回函数funv = bar() #执行函数bar()v() # 执行函数func()1234567name = '光头强'def func(): print(name)def bar(): return funcv = bar()v() # 光头强123456def bar(): def inner(): print(123) return innerv= bar() v() # 12312345678name = '光头强'def bar(): name = '花花' def inner(): print(name) return innerv = bar()v() # 花花123456789name = '光头强'def bar(name): def inner(): print(name) return innerv1 = bar('熊大')v2 = bar('熊二')v1() # 熊大v2() # 熊二123456789101112131415161718192021222324252627# 示例一name = '熊大'def base(): print(name) def func(): name = '熊二' base()func() # 熊大# 示例二name = '熊大'def func(): name = '熊二' def base(): print(name) base() func() # 熊二# 示例三name = '熊大'def func(): name = '熊二' def base(): print(name) return base base = func()base() # 熊二函数大高级把函数当做参数传递把函数当做返回值对函数进行复制递归含义：函数自己调自己(效率低)123456789101112def func(): print(1) func() func()# 示例def func(i): print(i) func(i+1) func(1) # 1,2,3---988报错，死循环斐契那波数列(有限制)12345678910def func(a,b): # 1 # 1 # 2 # 3 # 5 print(b) func(b,a+b) func(0,1)递归函数返回值123456789101112131415161718192021222324# 示例一def func(a): if a == 5: return 100000 result = func(a+1) + 10 return result v = func(1)print(v) # 10040# 示例二def func(a): if a == 5: return 100000 result = func(a+1) + 10v = func(1)name = 'alex'def func(): def inner(): print(name) return innerv =func()函数执行的流程分析函数是由谁创建的1234567891011121314151617181920212223242526def base(): return i def func(arg): def inner(): return arg return innerbase_list = [] # [base,base,]func_list = [] # [由第一次执行func函数的内存地址，内部arg=0 创建的inner函数，有arg=1的inner函数 ]for i in range(10): # i = 0 ，1 base_list.append(base) func_list.append(func(i)) # 1. base_list 和 func_list中分别保存的是什么？"""base_list中存储都是base函数。func_list中存储的是inner函数，特别要说的是每个inner是在不同的地址创建。"""# 2. 如果循环打印什么？for item in base_list: v = item() # 执行base函数 print(v) # 都是9for data in func_list: v = data() print(v) # 0 1 2 3 4闭包什么是闭包闭包概念：为函数创建一块区域并为其维护自己数据，以后执行时方便调用。闭包应用场景：装饰器、SQLAlchemy源码a函数里面有b函数,并且返回值为b函数（b函数只被调用，没被执行；b函数引用a函数的变量）示例123456789def func(name): def inner(): print(name) return inner v1 = func('熊大') # 执行func（）函数值为alex，返回innerv1() #执行inner（）函数，输出alexv2 = func('熊二')v2()lambda 表达式用于表示简单的函数12345678# 三元运算，为了解决简单的if else的情况，如：if 1 == 1: a = 123else: a = 456# 相当于a = 123 if 1==1 else 456print(a)1234567# lambda表达式，为了解决简单函数的情况，如：def funa(a1,a2): return a1 + 100print(funa(1,3)) # 101# 相当于func = lambda a1,a2: a1+100print(func(1,3)) # 10112345678910111213141516171819202122232425262728# 示例一func1 = lambda : 100print(func1()) #100func2 = lambda x1: x1 * 10print(func2(2)) # 20func3 = lambda *args,**kwargs: len(args) + len(kwargs)print(func3("a","b","c",k="sdfgg"，a = "dfgjh")) # 5# 示例二DATA = 100func4 = lambda a1: a1 + DATAv = func4(1)print(v) # 101# 示例三DATA = 100def func(): DATA = 1000 func4 = lambda a1: a1 + DATA v = func4(1) print(v) # 1001func()# 示例四func5 = lambda n1,n2: n1 if n1 &gt; n2 else n2v = func5(1111,2)print(v) # 11111234567891011121314151617181920212223242526272829# 练习题1USER_LIST = []def func0(x): v = USER_LIST.append(x) return vresult = func0('柯南')print(result) # Noneprint(USER_LIST) # ['柯南']# 练习题二def func0(x): v = x.strip() return v result = func0(' 柯南 ')print(result) # 柯南# 练习题三func_list = [lambda x:x.strip(), lambda y:y+199,lambda x,y:x+y]v1 = func_list[0]('柯南 ')print(v1) # 柯南v2 = func_list[1](100)print(v2) # 299v3 = func_list[2](1,2)print(v3) # 3内置函数强制转换dict() list() tuple() int() str() bool() set()输入和输出input print其他函数len(长度) open(打开) id(查看内存) range(输出列表) type(查看类型)数学相关abs(绝对值) float(转成浮点型：小数) max(找到最大值) min(找到最小值) sum(求和) divmod(求两数相除商和余数，多用于分页)123456789101112131415161718192021v = abs(-1)print(v) # 1v = 55v1 = float(55)print(v1) # 55.0v = [1,2,311,21,3,]result = max(v)print(result) # 311v = [1,2,311,21,3,]result = min(v)print(result) # 1v = [1,2,311,21,3,]result = sum(v)print(result) #338a,b = divmod(1001,5)print(a,b) # 200 1进制转换bin，将十进制转化成二进制(0b)123num = 13v1 = bin(num)print(v1) # 0b1101oct，将十进制转换成八进制(0o)123num = 8v1 = oct(num)print(v1) # 0o10int，将其他进制转化成十进制1234567891011121314# 二进制转化成十进制v1 = '0b1101'result = int(v1,base=2)print(result) #13# 八进制转化成十进制v1 = '0o1101'result = int(v1,base=8)print(result) # 577# 十六进制转化成十进制v1 = '0x1101'result = int(v1,base=16)print(result) # 4353hex，将十进制转换成十六进制(0x)123num = 16v1 = hex(num)print(v1) # 0x10编码相关chr，将十进制数字转换成unicode编码中的对应字符。12v = chr(99)print(v) # cord，将字符转换成unicode编码中的对应数字1num = ord('中')高级函数map会根据提供的函数对指定序列做映射第一个参数必须是一个函数第二个函数必须是可迭代类型（可以for循环）py2最后返回一个列表；py3最后返回一个对象（节省内存）循环每个元素（第二个参数），然后让每个元素执行函数（第一个）参数，将每个函数 执行的结果保存到新的列表中，并返回。123v1 = [11,22,33,44]result = map(lambda x :x+100,v1)print(list(result))#[111, 122, 133, 144]filter函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。循环每个元素（第二个参数），然后让每个元素执行函数（第一个）参数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。12345678910111213141516# 示例一v1 = [11,22,33,'fgd','egfghg',44,'sdf']def func(x): if type(x) == int:#判断v1元素是不是整型 return True#返回 return Flaseresult = filter(func,v1)#循环v1执行函数func,真的新建列表[11,]print(list(result))#输出result，默认是对象，转化为列表# 等于result = filter(lambda x: True if type(x) == int else False ,v1)print(list(result))# 等于result = filter(lambda x: type(x) == int ,v1)print(list(result))reduce函数会对参数序列中元素进行累积。函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。123456789101112# 示例import functoolsv1 = ['wo','hao','e']def func(x,y): return x+yresult = functools.reduce(func,v1)print(result)#wohaoe# 等于result = functools.reduce(lambda x,y:x+y,v1)print(result)type查看类型/判断对象是否是类的实例（找到头）1234567class Foo: passobj = Foo()if type(obj) = Foo: print("obj是Foo类的对象")issubclass判断类是否是子类（到头都是）1234567891011121314151617class Asd(): passclass Base(Asd): passclass Base1(Base): passclass Foo(Base1): passclass Bar: passprint(issubclass(Bar,Base)) # Falseprint(issubclass(Foo,Asd)) # Trueisinstance判断obj是否是Foo类或其基类的实例（对象），找到头都是12345678910111213class Asd: passclass Base(Asd): passclass Foo(Base): passobj = Foo()print(isinstance(obj,Foo))print(isinstance(obj,Asd))super根据self对象所属类的继承关系，按照顺序挨个找func方法并执行(找到第一个就不在找了)12345678910111213141516class Bar(object): def func(self): print('bar.func') return 123class Base(Bar): passclass Foo(Base): def func(self): v1 = super().func() print('foo.func',v1)obj = Foo() # bar.funcobj.func() # foo.func 123# super().func() 根据类的继承关系，按照顺序挨个找func方法并执行(找到第一个就不在找了)1234567891011121314class Base(object): # Base -&gt; object def func(self): super().func() print('base.func')class Bar(object): def func(self): print('bar.func')class Foo(Base,Bar): # Foo -&gt; Base -&gt; Bar passobj = Foo()obj.func() # bar.func base.func装饰器导入12345678910111213141516171819# 典例一v = 1v = 2print(v) # 2# 典例二def func(): passv = 10v = funcprint(v) # v 为函数地址# 典例三def base(): print(1)def bar(): print(2)bar = basebar() # 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 典例一def func(): def inner(): pass return innerv = func() # inner函数地址# 典例二def func(arg): def inner(): print(arg) return innerv1 = func(1) v1() # 1v2 = func(2)v2() # 2# 典例三def func(arg): def inner(): arg() return innerdef f1(): print(123)v1 = func(f1)v1() # 123# 典例四def func(arg): def inner(): arg() return innerdef f1(): print(123) return 666v1 = func(f1) #inner函数result = v1() #执行f1函数 123print(result) #返回值为None# 典例五def func(arg): def inner(): return arg() return innerdef f1(): print(123) return 666v1 = func(f1) # inner函数result = v1() # 执行inner函数 123 返回值为f1print(result) #打印f1返回值装饰器含义在不改变原函数内部代码的 基础上，在函数执行之前和之后自动执行某个功能基本格式123456789101112def func(age): def inner(): v = arg() return v return inner # 第一步：执行func函数并将下面函数参数传递，相当于：fun(index) # 第二步：将func的返回值重新赋值给下面的函数名，index = func（index）@funcdef index(): print(123) return 666print(index)装饰器编写格式1234def 外层函数(参数)： def 内层函数(*args,**kwargs) return 参数(*args,**kwargs) return 内层函数装饰器应用格式1234@外层函数def 参数(): passindex()问题为什么要加 *args, **kwargs答：可以接收参数函数里面任意值如果给好几个函数写一个统一的装饰器，怎么办？12345678910111213141516def a1(func): def inner(*args,**kwargs) return func(*args,**kwargs) return inner @a1def f1(): pass@a1def f2(): pass @a1def f2(): pass关于执行函数的前后123456789101112def a1(func): def inner(*args,**kwargs) print("调用函数之前") data = func(*args,**kwargs)# 执行函数并获取返回值 print("调用函数之后") return data return inner@a1def index(): print(123)index()带参数的装饰器123456789101112# 第一步：执行 ret = xxx(index)# 第二步：将返回值赋值给 index = ret@xxxdef index(): pass# 第一步：执行 v1 = uuu(9)# 第二步：ret = v1(index)# 第三步：index = ret@uuu(9)def index(): pass123456789101112# 格式 def x(counter): def wrapper(fnc): def inner(*args,**kwargs) data = func(*args,**kwargs) return data return inner def wrapper @x(9)def index(): pass查看带参数装饰器执行顺序12345678910111213141516171819def x(counter): print('x函数') def wrapper(func): print('wrapper函数') def inner(*args,**kwargs): print('inner函数') if counter: return 123 return func(*args,**kwargs) return inner return wrapper@x(True)def fun990(): pass@x(False)def func10(): # x函数 pass # wrapper函数迭代器引入任务展示列表中所有数据1、while + 索引 + 计数器2、迭代器迭代器含义对某种对象（str/list/tuple/dict/set类创建的对象），可迭代对象中元素逐一获取。什么是迭代器：具有’ __ next __ ‘ 的方法且每次调用都能获取可迭代对象中的每个元素（从前到后一一获取）迭代器使用123456789101112131415161718192021222324# 列表转换成迭代器：v1 = [1,2,3,4]v2 = iter(v1) #v2就是迭代器v2 = v1.__iter__()# 迭代器想要获取每个值：result1 = v2.__next__()print(result1)result2 = v2.__next__()print(result2)result3 = v2.__next__()print(result3)result4 = v2.__next__()print(result4)result5 = v2.__next__()print(result5)# 直到报错：StopIteration错误，表示已经迭代完毕。# 或者循环获取迭代器中的内容while True: try: val = v2.__next__() print(val) except Exception as e: break如何判别一个对象是否是迭代器：内部是否有__next__方法 。for循环实质1234567v1 = [11,22,33,44]# 1.内部会将v1转换成迭代器# 2.内部反复执行 迭代器.__next__()# 3.取完不报错for item in v1: print(item)可迭代对象1、表象：可以被循环对象就可以称为是可迭代对象：”x” [1,2] {}1234class Foo: passobj = Foo()2、内部具有 __iter__() 方法且返回一个迭代器。12v1 = [11,22,33,44]result = v1.__iter__() #result 就是迭代器3、可以被for循环如何让一个对象变成可迭代对象？在类中实现__iter__方法且返回一个迭代器（生成器）12345678910111213class Foo: def __iter__(self): return iter([1,2,3,4]) obj = Foo()class Foo: def __iter__(self): yield 1 yield 2 yield 3 obj = Foo记住：只有能被for循环就是去看内部的iter方法。迭代器口诀1、取一次就没有了2、不取就不执行取迭代器的值得方法1、list2、for循环3、next生成器实质就是函数的变异格式123456789101112# 生成器函数（内部是否包含yield）def func(): print("f1") yield 1 print("f2") yield 2 print("f3")# 函数内部不会被执行，返回一个生成对象v1 = func()# 生成器可以被for循环，一旦开始循环那么函数内部代码就会开始执行for item in v1: print(item)1234567891011# 无限循环打印1，2,3.....def func(): count = 1 while True: yield count count += 1 val = func()for item in val: print(item)总结函数中如果存在yield，那么该函数就是一个生成器函数，调用生成器函数会返回一个生成器，生成器只有被for循环时，生成器函数内部的代码才会被执行,每次执行都会获取yield返回的值练习123456789101112131415161718192021222324252627# 读取大文件def func(): """ 分批去读取文件中的内容，将文件的内容返回给调用者。 :return: """ cursor = 0 while True: f = open('db', 'r', encoding='utf-8')# 通过网络连接上redis # 代指 redis[0:10] f.seek(cursor) data_list =[] for i in range(10): line = f.readline() if not line: return data_list.append(line) cursor = f.tell() f.close() # 关闭与redis的连接 for row in data_list: yield rowfor item in func(): print(item)redis 源码示例]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数基础]]></title>
    <url>%2F637384435.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于Python中函数的概念、基本概念、返回值、参数、作用域等基本结构概念本质：将多行代码拿到别处并起个名字，以后通过名字就可以找到这行代码并执行应用场景代码重复执行代码量很多超过一屏，可以选择通过函数进行代码的分割写代码方式：面向过程—-函数式编程（多）—-面向对象编程基本结构123456# 函数的定义def 函数名(): 函数内容 pass# 函数的执行函数名()12345# 示例一def list_data(): v = [11,54,52] print(v[1])list_data() # 54函数如果不被调用，则内部永远不会被执行1234567891011121314151617181920212223242526# 练习题# 1.请写一个函数，函数计算列表 info = [11,22,33,44,55]中所有元素的和def list_data(): s = 0 info = [11, 22, 33, 44, 55] for i in info: s = s + i print(s)list_data() # 165# 2.请写一个函数，用函数将列表拼接起来def new_list(a,b): c = [] c.extend(a) c.extend(b) print(c)a1 = [555,4,6,5,6]a2 = [5646,86,6,]new_list(a1,a2) # [555, 4, 6, 5, 6, 5646, 86, 6]# 3.计算一个列表的长度def list_len(age): conten = 0 for i in age: conten +=1 print(conten)v = [11,2,'rtffd','r','g','fsd',77]list_len(v) # 7返回值函数没有返回值，默认返回：None函数内部执行过程中遇到return，就终止。return 可以返回任意类型如果return后面写了多个结果,,返回给调用者一个tuple(元祖),调用者可以直接使用解构获取多个变量123456789101112def func(): return (1,2,3)v = func()print(v) # (1, 2, 3)# 特殊:多个返回值，返回值为元组def func(): return 5,8,"alex"v = func()print(v) # (5, 8, 'alex')1234def func(age): #函数 return 9 # 返回默认值为9，默认：return Noneval = func('asdfghj')1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 示例一1.让用户输入一段字符串，计算字符串中有多少个A字符的个数，有多少就在a.txt中写多少个"大王八"def jisuan_a(aa): s = 0 for i in aa: if i =='A': s+=1 return sdef xieru_d(bb): if len(bb) == 0: return False with open('a.txt',mode='w',encoding='utf-8') as f: f.write(bb) return Truea = input("请用户输入")a1 = jisuan_a(a)b = "大王八" * a1b1 = xieru_d(b)print(b1)# 示例二2. 写函数，计算一个列表中有多少个数字，打印： 列表中有%s个数字。# # 提示：type('x') == int 判断是否是数字。def a_list(b): s = 0 for i in b: if type(i) == int: s = s + 1 print(s)a = input("请输入列表")a = a_list(a)# 示例三2. 写函数，计算一个列表中偶数索引位置的数据构造成另外一个列表，并返回。def a_list(b): b1 = b[::2] return b1a = input("请输入列表")a = a_list(a)# 示例三3. 读取文件，将文件的内容构造成指定格式的数据，并返回。a.log文件 alex|123|18 eric|uiuf|19 ...目标结构：a. ["alex|123|18","eric|uiuf|19"] 并返回。b. [['alex','123','18'],['eric','uiuf','19']]c. [ &#123;'name':'alex','pwd':'123','age':'18'&#125;, &#123;'name':'eric','pwd':'uiuf','age':'19'&#125;,]# adef a_1(a): b = [] # a = open('log.txt',mode='r',encoding='utf-8') for i in a: i = i.strip() b.append(i) print(b) returna1 = a_1(open('log.txt',mode='r',encoding='utf-8'))# bdef a_1(a): b = [] for i in a: i = i.strip() i = i.split('|') b.append(i) print(b) returna1 = a_1(open('log.txt',mode='r',encoding='utf-8'))# cdef a_1(a): b = [] c = &#123;&#125; for i in a: i = i.strip() i = i.split('|') c['name'] = i[0] c['pwd'] = i[1] c['age'] = i[2] b.append(c) print(b) returna1 = a_1(open('log.txt',mode='r',encoding='utf-8'))参数形参、实参123456def get_data(a):#a为形式参数（或形参） v = [1,5,6,,8,5] print(v[a])get_data(1)# 1在调用函数是传递叫：实际参数（实参）# 严格按照顺序传参数：位置方式传参。# 实际参数可以是任意类型。基本参数任意个数任意类型123def func(a1,a2,a3): print(a1,a2,a3) func(1,"asdf",True) # 1 asdf True位置传参调用函数并传入函数【执行】123def func(a1,a2): print(a1,a2)func(11,22) # 11 22关键字传参【执行】123456789# 典例一def func(a1,a2): print(a1,a2)func(a2=11,a1=22) # 22 11# 典例二def func(a1,a2): print(a1,a2)func(11,a2=22) # 11 22位置传参&gt;关键字传参（顺序）位置传参 + 关键字传参 = 总传参个数前面是关键字传参，后面也必须关键字传参默认参数【参数】 对于函数的默认值慎用可变类型123456789101112131415161718# 如果要想给value设置默认是空列表# 不推荐(坑)def func(data,value=[]): pass # 推荐def func(data,value=None): if not value: value = [] # 练习 def func(data,value=[]): value.append(data) return value v1 = func(1) # [1,]v2 = func(1,[11,22,33]) # [11,22,33,1]def func(a,b=[]) 有什么陷阱？1234567891011121314151617181920# 典例一def func(a,b=[]): b.append(a) return bl1 = func(1)print(l1) # [1]l2 = func(2,[11,22])print(l2) # [11,22,2]l3 = func(3)print(l3) # [1,2]# 示例二def func(a,b=[]): b.append(a) print(b) func(1) # [1]func(2,[11,22,33]) # [11,22,33,2]func(3) # [1,3]12345678910def func(a1,a2,a3=9,a4=10): print(a1,a2,a3,a4)func(11,22) # 11,22,9,10func(11,22,10) # 11,22,10,10func(11,22,10,100) # 11,22,10,100func(11,22,10,a4=100) # 11,22,10,100func(11,22,a3=10,a4=100) # 11,22,10,100func(11,a2=22,a3=10,a4=100) # 11,22,10,100func(a1=11,a2=22,a3=10,a4=100) # 11,22,10,100万能参数【打散】*args可以接受任意个数的位置参数，并将参数转换成元组.调用函数无 *12345 def func(*args): print(args)func((1,2,3,4)) # ((1,2,3,4),)func([1,2,3,4]) # ([1, 2, 3, 4],)调用函数有 *12345def func(*args): print(args)func(*(1,2,3,4)) # (1, 2, 3, 4)func(*[1,2,3,4]) # (1, 2, 3, 4)只能用位置传参1234567def func(*args): print(args)func(1) # ()func(1,2) # (1,2) func((11,22,33,44,55)) # ((11,22,33,44,55),)func(*(11,22,33,44,55)) # (11,22,33,44,55)**kwargs可以接受任意个数的关键字参数，并将参数转换成字典。调用函数无 **1234def func(**kwargs): print(kwargs)func(k1=1,k2="alex") # &#123;'k1':1,'k2':'alex'&#125;调用函数有**123def func(**kwargs): print(kwargs)func(**&#123;'k1':'v2','k2':'v2'&#125;) # &#123;'k1':'v2','k2':'v2'&#125;只能用关键字传参综合应用：无敌 + 无敌 =&gt; 真无敌1234567def func(*args,**kwargs): print(args,kwargs)func(1,2,3,4,5,k1=2,k5=9,k19=999)#(1, 2, 3, 4, 5) &#123;'k1': 2, 'k5': 9, 'k19': 999&#125;func([1,2,3],k1=2,k5=9,k19=999)# ([1, 2, 3],) &#123;'k1': 2, 'k5': 9, 'k19': 999&#125;func([1,2,3],**&#123;'k1':1,'k2':3&#125;)# (1, 2, 3) &#123;'k1': 1, 'k2': 3&#125;func(111,222,*[1,2,3],k11='alex',**&#123;'k1':1,'k2':3&#125;)#(111, 222, 1, 2, 3) &#123;'k11': 'alex', 'k1': 1, 'k2': 3&#125;参数相关重点定义函数12345678def func1(a1,a2): pass def func2(a1,a2=None): pass def func3(*args,**kwargs): pass调用函数位置参数 &gt; 关键字参数作用域python中py文件：全局作用域函数：局部作用域12345678910111213141516a = 1def s1(): x1 = 666 print(x1) #666 print(a) #1 print(b) #2b = 2print(a) #1s1()a = 88888def s2(): print(a,b) #88888,2 s1() #666,88888,2s2()一个函数是一个作用域12345def func(): x = 9 print(x) #9func()print(x) #9作用域中查找数据规则：优先在自己的作用域找数据，自己没有就去 “父级” -&gt; “父级” -&gt; 直到全局，全部么有就报错。注意：父级作用域中的值到底是什么？123456789101112131415161718192021222324252627282930# 示例一x = 10def func(): x = 9 print(x) #9func()# 练习题x = 10def func(): x = 9 print(x) #9 def x1(): x = 999 print(x) # 999func()x = 10def func(): x = 9 print(x) # 9 def x1(): x = 999 print(x) # 999 print(x) # 9 x1()func()子作用域中只能 找到父级中的值 ，默认无法重新为父级的变量进行赋值，但可以修改。(global/nonlocal可以强制做)global ：对全局的变量进行赋值nonlocal ： 找到上一级的局部变量进行赋值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 示例一name = '熊大'def func(): name = '熊二' # 在自己作用域再创建一个这样的值。 print(name) # 熊二func()print(name) # 熊大# 示例二name = [1,2,43]def func(): name.append(999) print(name) # [1, 2, 43, 999]func()print(name) #[1, 2, 43, 999]# 示例三name = ["熊大",'熊二']def func(): global name name = '我' print(name) # 我func()print(name) # 我# 示例四name = "熊大"def func(): name = '熊二' def inner(): global name name = 999 inner() print(name) # 熊二func()print(name) # 999# 示例五name = "熊大"def func(): name = '熊二' def inner(): nonlocal name # name = 999 inner() print(name) # 999func()print(name) # 熊大总结基本结构1234567891011121314151617181920# 情况一def f1(): passf1()# 情况二def f2(a1): passf2(123)# 情况三def f3()： return 1v1 = f3()# 情况四def f4(a1,a2): #.... return 333v2 = f4(1,22)if__name__ == ‘__main__‘__name__ == ‘__main__‘ 执行的文件就是__name__所在的文件控制当这个py文件被当作脚本直接执行的时候，就执行这里面的代码__name__ == ‘文件名’ __name__就是所在文件被导入的时候当这个py文件被当作模块导入的时候，就不执行这里面的代码参数调用（执行）函数时，传参：位置参数 &gt; 关键字参数定义函数：12345def func(a)def func(a,b=None) # 对于默认值，如果是可变类型，----&gt; 坑。 def func(*args,**kwargs)作用域函数为作用域自己 &gt; 父级 &gt; 父级 &gt; 全局 【读/修改（可变）】重新赋值：​ global​ nonlocal全部变量以后必须全部是大写123456789USER_LIST = [11,22,3]def func(): name = 'asdf' USER_LIST.append(12) USER_LIST.append(name)func()print(USER_LIST)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python的那个文件操作]]></title>
    <url>%2F156538331.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍Python中的文件操作具体都有哪些模式案例用word操作一个文件的流程如下：找到文件，双击打开读或修改保存&amp;关闭用python操作文件也差不多：12345f=open(filename) # 打开文件f.write("我是野生程序员") # 写操作f.read() # 读操作f.close() # 保存并关闭不过有一点跟人肉操作word文档不同，就是word文档只要打开了，就即可以读、又可以修改。 但Python比较变态，只能以读、创建、追加 3种模式中的任意一种打开文件，不能即写又读。操作模式r 只读模式w 创建模式，若文件已存在，则覆盖旧文件a 追加模式，新数据会写到文件末尾创建文件1234f = open(file='D:/工作日常/work.txt',mode='w')f.write("经理\n")f.write("秘书\n")f.close()只读模式1234f = open(file='兼职白领学生空姐模特护士联系方式.txt',mode='r')print(f.readline()) # 读一行print('------分隔符-------')data = f.read() # 读所有，剩下的所有print(data)f.close()追加模式123f = open(file='兼职白领学生空姐模特护士联系方式.txt',mode='a')f.write("白雪公主 北京 168 48\n") # 会追加到文件尾部f.close()其它功能123456789101112131415161718192021222324252627282930313233343536def mode(self) -&gt; str: 返回文件打开的模式 def name(self) -&gt; str: 返回文件名 def fileno(self, *args, **kwargs): # real signature unknown 返回文件句柄在内核中的索引值，以后做IO多路复用时可以用到 def flush(self, *args, **kwargs): # real signature unknown 把文件从内存buffer里强制刷新到硬盘 def readable(self, *args, **kwargs): # real signature unknown 判断是否可读 def readline(self, *args, **kwargs): # real signature unknown 只读一行，遇到\r or \n为止 def seek(self, *args, **kwargs): # real signature unknown 把操作文件的光标移到指定位置 *注意seek的长度是按字节算的， 字符编码存每个字符所占的字节长度不一样。 如“小兔崽子” 用gbk存是2个字节一个字，用utf-8就是3个字节，因此以gbk打开时，seek(4) 就把光标切换到了“兔”和“崽”两个字中间。 但如果是utf8,seek(4)会导致，拿到了兔这个字的一部分字节，打印的话会报错，因为处理剩下的文本时发现用utf8处理不了了，因为编码对不上了。少了一个字节 def seekable(self, *args, **kwargs): # real signature unknown 判断文件是否可进行seek操作 def tell(self, *args, **kwargs): # real signature unknown 返回当前文件操作光标位置def truncate(self, *args, **kwargs): # real signature unknown 按指定长度截断文件 *指定长度的话，就从文件开头开始截断指定长度，不指定长度的话，就从当前位置到文件尾部的内容全去掉。 def writable(self, *args, **kwargs): # real signature unknown 判断文件是否可写混合模式其实我一直像你隐瞒，因为怕你觉得复杂。 打开文件其实还有3种混合模式w+ 写读 , 这个功能基本没什么意义，它会创建一个新文件 ，写一段内容，可以再把写的内容读出来，没什么卵用。r+ 读写，能读能写,但都是写在文件最后，跟追加一样a+ 追加读,文件 一打开时光标会在文件尾部,写的数据全会是追加的形式r+模式因为默认就是往文件 尾部写修改文件尝试直接以r+模式打开文件，默认会把新增的内容追加到文件最后面。但我想要的是修改中间的内容 ，怎么办？ 为什么会把内容添加到尾部呢？问：为什么原有数据会被覆盖呢？这是硬盘的存储原理导致的，当你把文件存到硬盘上，就在硬盘上划了一块空间，存数据，等你下次打开这个文件 ，seek到一个位置，每改一个字，就是把原来的覆盖掉，如果要插入，是不可能的，因为后面的数据在硬盘上不会整体向后移。所以就出现 当前这个情况 ，你想插入，却变成了会把旧内容覆盖掉。问：但是人家word, vim 都可以修改文件 呀，你这不能修改算个什么玩意？我并没说就不能修改了，你想修改当然可以，就是不要在硬盘上修改，把内容全部读到内存里，数据在内存里可以随便增删改查，修改之后，把内容再全部写回硬盘，把原来的数据全部覆盖掉。vim word等各种文本编辑器都是这么干的。问：说的好像有道理，但你又没看过word软件的源码，你凭什么这么笃定？哈哈，我不需要看源码，硬盘 的存储原理决定了word必须这么干 ，不信的话，还有个简单的办法来确认我说的，就是用word or vim读一个编辑一个大文件 ，至少几百MB的，你 会发现，加载过程会花个数十秒，这段时间干嘛了？ cpu 去玩了？去上厕所啦？ 当然不是，是在努力把数据 从硬盘上读到内存里。问：但是文件如果特别大，比如5个GB,读到内存，就一下子吃掉了5GB内存，好费资源呀，有没有更好的办法呢？如果不想占内存，只能用另外一种办法啦，就是边读边改， 什么意思？ 不是不能改么？是不能改原文件 ，但你可以打开旧文件 的同时，生成一个新文件呀，边从旧的里面一行行的读，边往新的一行行写，遇到需要修改就改了再写到新文件 ，这样，在内存里一直只存一行内容。就不占内存了。 但这样也有一个缺点，就是虽然不占内存 ，但是占硬盘，每次修改，都要生成一份新文件，虽然改完后，可以把旧的覆盖掉，但在改的过程中，还是有2份数据 的。问：还有更好的方式么？有完没完？ 没了。占硬盘方式的文件修改代码示例1234567891011121314f_name = "兼职白领学生空姐模特护士联系方式.txt"f_new_name = "%s.new" % f_nameold_str = "刘诺涵"new_str = "[黑姑娘]"f = open(f_name,'r')f_new = open(f_new_name,'w')for line in f: if old_str in line: new_line = line.replace(old_str,new_str) else: new_line = line f_new.write(new_line)f.close()f_new.close()上面的代码，会生成一个修改后的新文件 ，原文件不动，若想覆盖原文件1234567891011121314151617import osf_name = "兼职白领学生空姐模特护士联系方式.txt"f_new_name = "%s.new" % f_nameold_str = "刘诺涵"new_str = "[黑姑娘]"f = open(f_name,'r')f_new = open(f_new_name,'w')for line in f: if old_str in line: new_line = line.replace(old_str,new_str) else: new_line = line f_new.write(new_line) f.close()f_new.close()os.rename(f_new_name,f_name) #把新文件名字改成原文件 的名字，就把之前的覆盖掉了,windows使用os.replace # 帮助文档说明replace会覆盖原文件]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash是个什么东东]]></title>
    <url>%2F2852062086.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍什么是哈希，以及哈希的用途，基于hash的数据类型有那些什么是哈希？含义hash,一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间。它其实就是一个算法，最简单的算法就是加减乘除，比方，我设计个数字算法，输入+7=输出，比如我输入1，输出为8；输入2，输出为9。哈希算法不过是一个更为复杂的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈希运算后，变成一个固定长度的输出，该输出就是哈希值。但是哈希算法有一个很大的特点，就是你不能从结果推算出输入,所以又称为不可逆的算法示例12hash('我爱你')3471388576844338423hash('小姐姐')5000768010434506639如上所示，输入“我爱你”三个字，经过哈希运算后，会得到一个随机数列，而且不管你的输入文件多大，最后得到的结果都是这么一个固定长度的数列，即使你输入的是一部电影，输出也是这么大。而且通过数列不能推导出输入。哈希特性​ 不可逆：在具备编码功能的同时，哈希算法也作为一种加密算法存在。即，你无法通过分析哈希值计算出源文件的样子，换句话说：你不可能通过观察香肠的纹理推测出猪原来的样子。​ 计算极快：20G高清电影和一个5K文本文件复杂度相同，计算量都极小，可以在0.1秒内得出结果。也就是说，不管猪有多肥，骨头多硬，做成香肠都只要眨眨眼的时间哈希的用途哈希算法的不可逆特性使其在以下领域使用广泛第一、密码，我们日常使用的各种电子密码本质上都是基于hash的，你不用担心支付宝的工作人员会把你的密码泄漏给第三方，因为你的登录密码是先经过 hash+各种复杂算法得出密文后 再存进支付宝的数据库里的第二、文件完整性校验，通过对文件进行hash，得出一段hash值 ，这样文件内容以后被修改了，hash值就会变。 MD5 Hash算法的”数字指纹”特性，使它成为应用最广泛的一种文件完整性校验和(Checksum)算法，不少Unix系统有提供计算md5 checksum的命令。第三、数字签名，数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。此外，hash算法在区块链领域也使用广泛。基于hash的数据类型有哪些？Python 中基于hash的2个数据类型是dict and set , 之前说dict查询速度快，为何快？ 说set天生去重，怎么做到的？其实都是利用了hash的特性，我们下面来剖析dict 为何查询速度超快，且不受dict大小影响 ？解析：假设我要存14亿人的基本信息12345data = &#123; "张三":[23742364782642342323234,28,"山东济南"], "李四":[12124234232311214458271,25,"北京昌平"], "王五":[23030293483727384383929,33,"山东济南"], "赵六":[42302033030302482634674,28,"河北保定"], # ...&#125;dict会把这些数字按大小排序好放在一个列表里kd = [-10, 53, 67, 81, 99, 123]当我们想查找”赵六”的信息时， 会把“赵六”先hash, 得到99这个值，然后拿这个值去到kd列表里找，想象这个列表有14亿个值 ，如何快速找到99？ 二分法就行，具体看剖析视频。只要找到了99的位置，就可以定位到赵六对应的value的值了。 通过2分法查找，每次数据量都会少一半，这样查找最多31次(2**31=2147483648)就能从20亿信息里找到这个人的信息。当然 dict 真实的查找算法比这个还要复杂些， 我只是通过这个例子让大家理解下为何基于hash的数据类型查找速度会快很多。set为何是天生去重的？​ 因为每存一个值到set里时， 都要先经过hash，然后通过得出的这个hash值算出应该存在set里的哪个位置，存的时候会先检查那个位置上有没有值 ，有的话就对比是否相等，如果相等，则不再存储此值。 如果不相等(即为空)，则把新值 存在这。​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中基础数据类型]]></title>
    <url>%2F1798410932.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于Python数据类中整型、布尔、字符串、列表、元祖、字典、集合的概念和数据结构以及特有的方法，公共方法整型（int）整型的长度py2中有：int/long在32位机器上，整数的位数为32位，取值范围为-231～231-1，即-2147483648～2147483647在64位系统上，整数的位数为64位，取值范围为-263～263-1，即-9223372036854775808～9223372036854775807超出长度之后就会变为long类型。py3中有：int （int/long）整除py2和py3中整除是不一样。注意：在python2中使用除法时，只能保留整数位，如果想要保留小数位，可以先导入一个模块。123from __future__ import division value = 3/2print(value)布尔（bool）布尔值就是用于表示真假。True和False。其他类型转换成布尔值为False：0“”[](){}set()None其他类型转换成布尔值为False：除了以上其他转换都是True字符串（str）​ 字符串是写代码中最常见的，python内存中的字符串是按照：unicode 编码存储。对于字符串是不可变。字符串自己有很多方法，如：upper 全部大写isupper() 将字符串中所有的小写字母变成大写字母12345v = 'ALEX'v1 = v.upper()print(v1)v2 = v.isupper() # 判断是否全部是大写print(v2)lower 全部小写将字符串中所有的大写字母变成小写字母1234567891011121314v = 'alex'v1 = v.lower()print(v1)v2 = v.islower() # 判断是否全部是小写print(v2)############ 了解即可v = 'ß'# 将字符串变小写（更牛逼）v1 = v.casefold()print(v1) # ssv2 = v.lower()print(v2)isdecimal 判断字符串是否是数字12345678910111213141516171819202122v = '1'# v = '二'# v = '②'v1 = v.isdigit() # '1'-&gt; True; '二'-&gt; False; '②' --&gt; Truev2 = v.isdecimal() # '1'-&gt; True; '二'-&gt; False; '②' --&gt; Falsev3 = v.isnumeric() # '1'-&gt; True; '二'-&gt; True; '②' --&gt; Trueprint(v1,v2,v3)# 以后推荐用 isdecimal 判断是否是 10进制的数。# ############## 应用 ##############v = ['啊','波','嚓']for i in v: print(i)num = input('请输入序号：')if num.isdecimal(): num = int(num) print(v[num])else: print('你输入的不是数字')strip 去除两边空格.lstrip() #去除左边空格 +\t+\n + 指定字符串.rstrip()#去除右边空格1234567891011v1 = "admin "print(v1.strip())v2 = "admin\t"print(v2.strip())v3 = "admin\n"print(v3.strip())v1 = "admina"print(v1.strip('al'))replace 替换(“被替换的字符/子序列”,”要替换为的内容”) .replace(“被替换的字符/子序列”,”要替换为的内容”,几次）.123456789# 示例一a = "abc23"b = a.replace("ab","12")print(b) # 12c23# 示例二a = "abc23abab"b = a.replace("ab","12",2)print(b) # 12c2312absplit 切割(‘根据什么东西进行分割’) #从左往右分割split(‘根据什么东西进行分割’, 几次) #从左往右分割rsplit(‘根据什么东西进行分割’) #从右往左分割rsplit(‘根据什么东西进行分割’, 几次) #从右往左分割partition(‘3’) # 将指定字符串分为三分：前面，自己，后面12345678910111213141516171819202122# 示例一a = "abc23abab"b = a.split("b")print(b) #['a', 'c23a', 'a', ''] # 示例二a = "abc23abab"b = a.split("b",2)print(b) # ['a', 'c23a', 'ab']# 示例三a = "abc23abab"b = a.rsplit("b")print(b) # ['a', 'c23a', 'a', '']# 示例三a = "abc23abab"b = a.rsplit("b",2)print(b) # ['abc23a', 'a', '']v1 = v.partition('3') # 将指定字符串分为三分：前面，自己，后面print(v1)startswith 判断是否以什么开头1234# 示例a = "abc23abab"b = a.startswith("a")print(b) # Trueendswith 判断是否以什么结尾1234# 示例a = "abc23abab"b = a.endswith("b")print(b) # Trueencode 指定的编码格式编码字符串12345name = '李杰' # 解释器读取到内存后，按照unicode编码存储：8个字节。v1 = name.encode('utf-8')print(v1)v2 = name.encode('gbk') # b'\xe6\x9d\x8e\xe6\x9d\xb0' b为字节print(v2) # b'\xc0\xee\xbd\xdc'format 字符串格式化format_map # 字符串格式化的功能。基本语法是通过 {} 和 : 来代替以前的 % 。format 函数可以接受不限个参数，位置可以不按顺序。123456789101112131415161718192021a = "&#123;&#125; &#123;&#125;".format("hello", "world") # 不设置指定位置，按默认顺序print(a) # 'hello world' a = "&#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置print(a) # 'hello world' a = "&#123;1&#125; &#123;0&#125; &#123;1&#125;".format("hello", "world") # 设置指定位置print(a) # 'world hello world'v= '我是&#123;0&#125;,谢谢谢 &#123;1&#125;'.format('alex',19)print(v)v= '我是&#123;x1&#125;,谢谢谢 &#123;xx&#125;'.format_map(&#123;'x1':'alex','xx':19&#125;)print(v)# v1 = "我是&#123;0&#125;,年龄&#123;1&#125;".format('alex',19)v1 = "我是&#123;0&#125;,年龄&#123;1&#125;".format(*('alex',19,))print(v1)# v2 = "我是&#123;name&#125;,年龄&#123;age&#125;".format(name='alex',age=18)v2 = "我是&#123;name&#125;,年龄&#123;age&#125;".format(**&#123;'name':'alex','age':18&#125;)print(v2)join 以指定的字符连接生成新的字符串。123name = 'abcd' # a_b_c_dresult = "+".join(name) # 循环每个元素，并在元素和元素之间加入连接符。print(result) # a+b+c+dcenter 原字符串居中，填充该方法返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。12345str = 'runoob'str.center(20, '*')'*******runoob*******'str.center(20)' runoob 'rjust 原字符串右右对齐，填充返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。123str = "this is string example....wow!!!"print (str.rjust(50, '*'))# ******************this is string example....wow!!!count 计算子序列出现的次数123v = 'aealeax'v1 = v.count('ea')print(v1)find 找到索引位置找索引位置(从左到右找到第一个),存在则返回索引位置，不存在则返回 -1index， 找索引位置(从左到右找到第一个),存在则返回索引位置，不存报错123v = 'alexex'index = v.find('u')print(index列表（list）格式1users = ["ji",1,3,"gyhj"]append 在列表的最后追加一个元素123456# 示例users = ["sdxfc"]while True: name = input('请输入姓名:') users.append(name) print(users) # ['sdxfc', 'sdf']insert 在指定索引位置进行插入元素123users = ['qwe','asd','zxc','rty']users.insert(1,'zxc')print(users) # ['qwe', 'zxc', 'asd', 'zxc', 'rty']remove 删除 注意：（）里不加删除内容报错pop 删除 注意：（）里不加数字，默认删除最后一个del 删除 注意：（）里不加数字报错clear 删除列表里所有元素 注意：（）里不能加数字12345678910111213141516users = ["ji",1,3,"gyhj"]# 方式一users.remove('ji')print(users) # [1, 3, 'gyhj']# 方式二users.pop(1)print(users) #['ji', 3, 'gyhj']# 方式三del users[1]print(users) #['ji', 3, 'gyhj']# 方式四users.clear()print(users) # []注意：字符串本身不能修改或删除【不可变类型】列表是【可变类型】reverse 反转1234v1 = [1,2,3111,32,13]print(v1) # [1, 2, 3111, 32, 13]v1.reverse()print(v1) # [13, 32, 3111, 2, 1]sort 排序12345v1 = [1,2,3111,32,13]v1.sort(reverse=False) # 从小到大（默认）print(v1) # [11, 13, 22, 32, 3111]v1.sort(reverse=True) # 从大到小print(v1) # [3111, 32, 22, 13, 11]extend 在列表末尾一次性追加另一个序列中的多个值12345list1 = ['Google', 'Runoob', 'Taobao']list2=list(range(5)) # 创建 0-4 的列表list1.extend(list2) # 扩展列表print ("扩展后的列表：", list1)# 扩展后的列表： ['Google', 'Runoob', 'Taobao', 0, 1, 2, 3, 4]元祖（tuble）格式​ users = [11,22,33] # 列表（元素可变）​ users = (11,22,33) # 元组（元素不可变）字典（dict）字典含义​ 帮助用户去表示一个事物的信息（事物是有多个属性）。基本格式1data = &#123;键:值,键:值,键:值,键:值,键:值,键:值,&#125;12345678# 练习题userinfo = &#123;'usenrame':'li','password':"xiangmin"&#125;user = input('请输入用户：')pwd = input('请输入密码：')if userinfo['username'] == user and userinfo['password'] == pwd: print('登陆成功')else: print('用户名或密码错误')1info = &#123;"name":'li','age':18,'gender':'男',&#125;keys 获取字典中所有的键12for item in info.keys(): print(item) #循环获取字典中所有的键values 获取字典中所有的值12for item in info.values(): print(item) #循环获取字典中所有的键items 获取字典中的所有键值对。12del info['gender']print(info) # &#123;'name': 'li', 'age': 18&#125;get 函数返回指定键的值，如果值不在字典中返回默认值。12345678# 示例 一dict = &#123;'Name': 'Zara', 'Age': 27&#125;print(dict.get('Age')) # 27# 示例 二dict = &#123;'Name': 'Zara', 'Age': 27&#125;print(dict.get('asd')) # Noneprint(dict.get('asd',"123")) # 123update 更新，字典里不存在增加/存在更新1234567891011# 示例 一dict = &#123;'Name': 'Runoob', 'Age': 7&#125;a = &#123;'Age':9&#125;dict.update(a)print(dict) # &#123;'Name': 'Runoob', 'Age': 9&#125;# 示例 二dict = &#123;'Name': 'Runoob', 'Age': 7&#125;dict2 = &#123;'Sex': 'female'&#125;dict.update(dict2)print("更新字典 dict :- ", dict)del 删除 键值对一个整体，要删全删pop 删除clear 删除（清空所有内容）123456789101112info = &#123;"name":'li','age':18,'gender':'男',&#125;# 方法一del info['gender']print(info) # &#123;'name': 'li', 'age': 18&#125;# 方法二a = info.pop('name')print(info) # &#123;'age': 18, 'gender': '男'&#125;# 方法三info.clear()print(info) # &#123;&#125;集合（set）集合含义​ 一个无序的不重复元素序列。​ 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。​ 空集合：set（）基本格式1a = &#123;1,2,3,4,5,6&#125;123parame = &#123;value01,value02,...&#125;# 或者set(value01,value02,...)add 添加：所添加值没有原值输出、新值增加123info = &#123;"name",'li','age',18,'gender','男',&#125;info.add(11)print(info) # &#123;'li', 11, 18, '男', 'gender', 'age', 'name'&#125;discard 删除：所删除值没有原值输出、不会报错123info = &#123;"name",'li','age',18,'gender','男',&#125;info.discard(18)print(info) #&#123;'男', 'li', 'name', 'age', 'gender'&#125;键update() 批量添加。123info = &#123;"name",'li','age',18,'gender','男',&#125;del info['gender']print(info) # &#123;'name': 'li', 'age': 18&#125;intersection 交集：生成新值。括号里可以列表、集合、元祖。123info = &#123;"name",'li','age',18,'gender','男',&#125;result = info.intersection(&#123;1,'li','男'&#125;)print(result) # &#123;'li', '男'&#125;union 并集：生成新值。括号里可以列表、集合、元祖。123info = &#123;"name",'li','age',18,'gender','男',&#125;result = info.union(&#123;1,'li','男'&#125;)print(result) # &#123;'gender', 1, '男', 18, 'name', 'age', 'li'&#125;difference 差集：生成新值。括号里可以列表、集合、元祖。123info = &#123;"name",'li','age',18,'gender','男',&#125;result = info.difference(&#123;1,'li','男'&#125;)print(result) # &#123;'name', 18, 'age', 'gender'&#125;symmetric_difference 对称差集：生成新值。括号里可以列表、集合、元祖。123info = &#123;"name",'li','age',18,'gender','男',&#125;result = info.symmetric_difference(&#123;1,'li','男'&#125;)print(result) # &#123;1, 'name', 'gender', 18, 'age'&#125;公共功能索引（排除：int/bool）123users = (11,22,33)print(users[0]) # 11print(users[-1]) # 33切片（排除：int/bool）12users = (11,22,33)print(users[0:2])步长（排除：int/bool)12users = (11,22,33,"qwerty")print(users[0:2:2])for循环（排除：int/bool)123users = (11,22,33,"qwerty")for item in users: print(item)len 长度（ 排除：int/bool）12users = (11,22,33,"qwerty")print(len(users))range 创建一个整数列表，一般用在 for 循环中。12345for i in range(1,11): if i == 7: pass else: print(i) # 1 2 3 4 5 6 8 9 10小数据池解析小数据池：is 两者之间的id是否相同== 两边的数值是否相等id 获取该对象的内存地址代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。而作为交互方式输入的每个命令都是一个代码块。如果在同一代码块下，则采用同一代码块下的换缓存机制。如果是不同代码块，则采用小数据池的驻留机制。pycharm 通过运行文件的方式执行下列代码： 这是在同一个文件下也就是同一代码块下，采用同一代码块下的缓存机制。代码示例123456789101112i1 = 1000i2 = 1000print(i1 is i2) # 结果为True 因为代码块下的缓存机制适用于所有数字通过交互方式中执行下面代码： # 这是不同代码块下，则采用小数据池的驻留机制。&gt;&gt;&gt; i1 = 1000&gt;&gt;&gt; i2 = 1000&gt;&gt;&gt; print(i1 is i2)False # 不同代码块下的小数据池驻留机制 数字的范围只是-5~256.#相同代码块下： #所有整数，大部分字符串，bool，存储地址相同#不同代码块下(小数据池)： #-5-256，字符串长度小于等于20，bool，存储地址相同]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门]]></title>
    <url>%2F228520744.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于Python中最基础的编码，变量，输入，输出，注释，判断语句，循环语句，运算符，三目运算等环境的安装解释器：py2 / py3 （环境变量）开发工具：pycharm编码编码基础ascii ,英文、符号，8位为一个东西，2**8unicode ，万国码，可以表示所有，32位为一个东西，2**32utf-8，unicode的压缩，用尽量少的位数表示一个东西，中文用3个字节=24位gbkgb2312python编码相关对于Python默认解释器编码：py2： asciipy3： utf-8如果想要修改默认编码，则可以使用：注意：对于操作文件时，要按照：以什么编写写入，就要用什么编码去打开。bytes 和 str 关系‘你不是人’ —— 字节 ； 计算机存储/网络传输 —– 二进制8位bit（比特） = 1个字节str + encode(编码) = bytesbytes + decode(编码) = str变量1.问：为什么要有变量？​ 为某个值创建一个“外号”，以后在使用时候通过此外号就可以直接调用。2 .变量命名规则只能是数字、字母、下划线。不能数字开头。不能是python关键字见名之意，建议下划线链接输入input输入得到的永远是字符串py2 和 py3的区别py2 ：name = raw_input(“你好”)py3 : name = input(“你好”)输出python2 : print”你好”python3: peint(“你好”)注释单行注释 #多行注释 “”” “””if 语句if1234if 条件： 代码块else 代码块elif123456if 条件： 代码块elif 条件： 代码块else: 代码块练习题1234567891011121314151617# 第一题：让用户输入一个数字，猜：如果数字 &gt; 50,则输出：大了； 如果数字 &lt;= 50 ,则输出：小了。num = input('请输入一个数字')number = int(num)if number &gt; 50: print('大了')else: print('小了') # 第二题：用户名密码登陆username = input('请输入用户名：')password = input('请输入密码：')if username == 'alex' and password == "oldboy" : print('欢迎登陆')else: print('用户名或密码错误')while 语句while123456while 条件: 代码块"""while True: print("你好")"""else123456789101112131415while 条件: 代码块else: # 当条件不在满足while后触发，或条件 = False 代码块"""count = 1while Ture: print(count) if count == 10: break count = count + 1else: print("代码块")print（"结束"）"""break (终止当前循环)12345678# 通过break实现 1 ~ 10count = 1while True: print(count) if count == 10: break count = count + 1print('结束')continue(本次循环如果遇到continue，则不再继续往下走，而是回到while条件位置)12345conunt = 1while count &lt;=10: print(count) continue count = count + 1字符串格式化%s 直接做占位符%d数字占位符%% 表示%运算符算数运算比较运算赋值运算逻辑运算优先级三元(目)运算格式示例a = 1,b = 2 交换a,b变量a,b = b,ac = a, b = a ,a = c书写规范PEP8规范特殊字符\n 换行\t tab键（制表符）\r 回到当前行起始位置—应用进度条pycharm自动生成头部代码项目结构目录项目调用书写规范单可执行文件多可执行文件src —- 业务相关 比如 stdent.py core.pylib —- 公用的类库db —- 数据/库config —- 配置bin —- 可执行文件（根目录）log —- 日志文件]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础]]></title>
    <url>%2F3347313358.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于认识计算机的基础硬件，操作系统，应用软件，故障分析，网络介绍及分类，网络介质和设备，OSI协议，IP协议计算机基础认识计算机计算机，俗称电脑，是现代一种用于高速计算的电子机器，可以进行数值运算一台完整的计算机有硬件系统和软件系统组成计算机分类超级计算机工业控制计算机网络计算机个人计算机嵌入式计算机计算机的发展第一代 电极管数字机第二代 晶体管数字机第三代 集成电路数字机第四代 大规模集成电路冯.诺依曼 提出计算机体系计算机五部分采用二进制形式表示数据和指令数据和指令放到计算机中，随拿随用CPU负责运算和控制，计算机的大脑参考指标主频 越高越快 运算能力缓存 默认 三级，好的四级核数 几个核数就是几个工人接口LGA 新式 铜片PGA 老式 针式常见故障温度过高 死机 重启超频硬盘负责存储数据永久存储低速设备分类机械固态参考指标容量转速/读写速度缓存大小内存负责存储数据随机存储高速设备参考指标容量频率 越大内存越快常见故障电脑开不开机用橡皮或者粗糙的纸擦一擦主板计算机的硬件平台技术越高，可用时间越长显卡负责显示参考指标显存位宽 越大显卡越贵，性能越好，存取速度频率人机对话的重要设备之一其他机箱抗辐射散热好满足扩展需求分类：标准、加大电源计算机弱电人体不能有静电提供电源接口电源功率网卡有线无线声卡主板集成也可以自己扩展显示器分辨率高的操作系统它是一段程序代码计算机程序负责管理硬件负责驱动硬件应用程序平台常见操作系统微软Windows7/8/10 个人操作系统2008/2012 网络版 应用服务器LinuxFedora 可以用于个人centosrhelubuntu 可以用于个人suseMac应用软件面向用户的计算机程序处理某一方面工作故障分析排除方法快速定位问题方向自检 是否出现Windows是 系统有问题否 硬件故障主板 一般不会坏CPU 一般不会坏内存 替换法显卡 替换法硬盘 最容易坏排除法找硬件故障通过PE备份数据，重装系统网络基础网络介绍及分类计算机网络是由通讯介质将地理位置不同的且相互独立的计算机连接起来，实现数据通讯与资源共享网络类型按拓扑分总线型 效率低 最早的环形 几乎看不见星型 线路单一，中央器压力大，产生单点故障网型按地域 参照物不同，类型不同局域网 LAN城域网 MAN广域网 WAN网络介质和设备网络设备交换机 switch负责组件局域网，计算机到计算机的数据传输，研究的是MAC地址 – 网卡48位二进制，全球唯一路由器 router负责组建广域网，网络到网络的数据传输，研究的是IP地址通讯介质同轴电缆双绞线 常用有线 理论最大传输距离100米，建议不要超过90米 超过这个距离，中间放一个中继器或交换机按速度分 5类、超5类（百兆）、6类（千兆）按特点分 屏蔽和非屏蔽光纤 常用有线多模光纤：只能传输一种模式的光，传输距离远，是多模光纤的几十倍以上，单模光纤外面护套线颜色一般为黄色单模光纤：可以传输多种模式的光，多模光纤传输的距离比较近，一般只有几千米，多模光纤外面颜色一般为橘红色光纤速度光纤的极限传输家用的普通光纤就可达到10Gbps以上。实验室中单条光纤最大速度已达到了26Tbps，有消息说通过石墨烯制造的新光调制器，还可继续提高10000倍，即260Pbps。电磁信号蓝牙OSI与ISOISO介绍国际标准化组织简称ISO，是一个全球性的非政府组织中国国家技术监督局1977年提出一个七层模型，主要用于数据库的访问OSI七层模型应用层 用户接口 HTTP表示层 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）会话层 不同机器上的用户间 建立、管理、终止会话。（在五层模型里面已经合并到了应用层）传输层 TCP协议 安全 速度慢 UDP协议 不安全 速度快网络层 控制子网的运行 逻辑链路寻址 IP地址数据链路层 物理寻址 交换机物理层 传输的是信号优点概念清楚、理论也比较完整，但他既复杂有不实用，ISO制定的OSI参考模型过于庞大，复杂招致了许多批评TCP和IP四层包含 应用层（上三层）、传输层、网络层、网络接口层（下两层），不过从实质上讲，TCP/IP只有最上面的三次网络接口层操作系统中的设备驱动程序和计算机中对应的网络接口层应用层负责处理特定的应用程序细节。几乎各种不同的 TCP/IP实现都会提供下面这些通用的应用程序:Telnet 远程登录。FTP 文件传输协议。SMTP 简单邮件传送协议。SNMP 简单网络管理协议。网络层有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议(网际协议)，ICMP协议(Internet互联网控制报文协议 ，以及IGMP协议(Internet组管理协议 )。TCP和UDPTCPTCP和 UDP 是两种最为著名的传输层协议，二者都使用 I P 作 为 网 络 层 协 议尽管 TCP 和 UDP 都使用相同的网络层( IP )， TCP 却向应用层提供与 UDP 完全不同的服务。 TCP 提供一种面向连接的、可靠的字节流服务。TCP: 传输控制协议,面向连接的协议面向连接意味着两个使用 TCP 的 应 用 ( 通 常 是 一 个 客 户 和 一 个 服 务 器 ) 在 彼 此 交 换 数 据 之前必须先建立一个 TCP 连 接 。一对一传输UDP协议UDP（User Datagram Protocol），用户数据报协议，是OSI(Open System Interconnection，开放式系统互联) 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务,UDP提供了无连接通信，适合于一次传输少量数据,UDP报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。可以一对一、一对多传输、多对一和多对多的交互通信TCP与UDP区别：TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付，Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信TCP对系统资源要求较多，UDP对系统资源要求较少。ipip地址IP介绍IPV4地址IPV6地址VLSMip介绍IP是英文Internet Protocol的缩写，意思是“网络之间互连的协议”，也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。正是因为有了IP协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP协议也可以叫做“因特网协议”。IP地址是指互联网协议地址，IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址。大家日常见到的情况是每台联网的PC上都需要有IP地址，才能正常通信。我们可以把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，而Internet中的路由器，就相当于电信局的“程控式交换机”。IP是一个协议，是计算机在网络中互联互通的规则IP地址是IP实现互联互通的一个策略ip地址和Mac地址IP地址是软件地址，而不是硬件地址。硬件地址被硬编码到网络接口卡(NIC)中，用于在本地 网络中寻找主机。 IP地址让一个网络中的主机能够与另一个网络中的主机通信，而不管这些主机所属的LAN是什么类型的。MAC用于局域网中通信，交换机通过mac地址将数据包转发到正确的计算机IP用于网络间通信ip地址的分类IPV4:32位二进制 以点分割，分为4段十进制数 a.b.c.dIPV6:128位二进制 以冒号分割,分为8段十六进制数 a​:b:​c:d:e:f:g:hipv4ipv4地址IPV4地址长 32位，这些位被划分成 4组(称为字节或八位组)，每组8位,每组最大不超过255，我们可使用下面3种方法描述IP地址:点分十进制表示，如 192.168.0.1。二进制，如 11000000.10101000.00000000.00000001十六进制，如 c0.a8.0.1。上述示例表示的是同一个IP地址。对于IP编址时，十六进制表示没有点分十进制和二进制那样常用，但某些程序确实以十六进制形式存储IP地址， Windows注册表就将机器的IP地址存储为十六进制。地址分类按照第一段的范围分类A 1-126B 128-191C 192-223D 224-239E 240-255设计因特网的人决定根据网络规模创建网络类型。对于少量包含大量节点的网络，他们创建了A类网络;对于另一种极端情况的网络，他们创建了C类网络，用来指示大量只包含少量节点的网络; 介于超大型和超小型网络之间的是B类网络。所以IPV4五类地址中只有前三类可以分给用户试用，D类是多播地址，E类为保留地址，用于研究。网络的类型决定了 IP地址将如何划分成网络部分和节点部分子网掩码子网掩码：区分IP地址的网络位和主机位255.0.0.0255.255.0.0255.255.255.0255.255.255.255网络位:掩码对应的IP位的二进制部分，全为1的部分是网络位主机位:掩码对应的IP位的二进制部分，不全为1的部分是主机位进制转换方法十进制转二进制: 除2取余倒着念十进制转八进制: 除8取余倒着念十进制转十六进制: 除16取余倒着念ip分配原则只有A、B、C三类地址可以分配给计算机和网络设备网络地址相同主机地址必须唯一网络地址的第一个数字不能为127，保留用来测试连接网络地址不能全为0，也不能全为1.主机地址中不能全为0，也不能全为1：主机地址全为0用来表示网络地址，全为1用作广播ipv6概念由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍互联网数字分配机构（IANA）在2016年已向国际互联网工程任务组（IETF）提出建议，要求新制定的国际互联网标准只支持IPv6，不再兼容IPv4。ipv6组成IPv6的地址长度为128位，是IPv4地址长度的4倍。于是IPv4点分十进制格式不再适用，采用十六进制表示。分类单播地址（Unicast Address）用来标识一组接口（通常这组接口属于不同的节点），类似于IPv4中的组播地址。发送到组播地址的数据报文被传送给此地址所标识的所有接口。组播地址（Multicast Address）任播地址（Anycast Address）特殊地址下面列出一些绝对应该牢记的地址范围，因为我们总是会用到它们。它们都是特殊地址或保留用 于特定目的的地址，但不同于 IPv4， IPv6提供的地址非常多，因此保留一些不会有任何害处。IPV6为啥这么多年没广泛应用网络黑白名单需要时间去建立，否则网络威胁无法解决。目前骨干线路已经全部使用了IPV6地址，随着物联网的出现，IPV6会更快完成替换。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端大道]]></title>
    <url>%2F1377344835.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于本博客空间关于前端基础的所有博文目录]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础目录]]></title>
    <url>%2F3415104752.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于本博客空间关于Linux基础的所有博文目录]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python博文目录]]></title>
    <url>%2F4138033636.html</url>
    <content type="text"><![CDATA[摘要：​ 本博文主要介绍关于本博客空间关于Python相关的所有博文目录1、计算机基础2、python入门3、Python中基础数据类型4、hash是个什么东东5、Python的那个文件操作6、Python函数基础7、Python函数的高级8、python模块介绍9、Python基础模块大全10、Python中的面向对象是谁的对象11、深入面向对象]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F1243066710.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
